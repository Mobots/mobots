   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"fix16.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.section	.rodata
  19              		.align	2
  22              	FOUR_DIV_PI:
  23 0000 F3450100 		.word	83443
  24              		.align	2
  27              	_FOUR_DIV_PI2:
  28 0004 4098FFFF 		.word	-26560
  29              		.align	2
  32              	X4_CORRECTION_COMPONENT:
  33 0008 9A390000 		.word	14746
  34              		.align	2
  37              	PI_DIV_4:
  38 000c 0FC90000 		.word	51471
  39              		.align	2
  42              	THREE_PI_DIV_4:
  43 0010 2F5B0200 		.word	154415
  44              		.align	2
  47              	fix16_max:
  48 0014 FFFFFF7F 		.word	2147483647
  49              		.align	2
  52              	fix16_min:
  53 0018 00000080 		.word	-2147483648
  54              		.align	2
  57              	fix16_overflow:
  58 001c 00000080 		.word	-2147483648
  59              		.align	2
  62              	fix16_pi:
  63 0020 3F240300 		.word	205887
  64              		.align	2
  67              	fix16_e:
  68 0024 E1B70200 		.word	178145
  69              		.align	2
  72              	fix16_one:
  73 0028 00000100 		.word	65536
  74              		.text
  75              		.align	2
  76              		.thumb
  77              		.thumb_func
  79              	int64_lo:
  80              	.LFB9:
  81              		.file 1 "../libfixmath/int64.h"
   1:../libfixmath/int64.h **** #ifndef __libfixmath_int64_h__
   2:../libfixmath/int64.h **** #define __libfixmath_int64_h__
   3:../libfixmath/int64.h **** 
   4:../libfixmath/int64.h **** #ifdef __cplusplus
   5:../libfixmath/int64.h **** extern "C"
   6:../libfixmath/int64.h **** {
   7:../libfixmath/int64.h **** #endif
   8:../libfixmath/int64.h **** 
   9:../libfixmath/int64.h **** #ifndef FIXMATH_NO_64BIT
  10:../libfixmath/int64.h **** static inline  int64_t int64_const(int32_t hi, uint32_t lo) { return (((int64_t)hi << 32) | lo); }
  11:../libfixmath/int64.h **** static inline  int64_t int64_from_int32(int32_t x) { return (int64_t)x; }
  12:../libfixmath/int64.h **** static inline  int32_t int64_hi(int64_t x) { return (x >> 32); }
  13:../libfixmath/int64.h **** static inline uint32_t int64_lo(int64_t x) { return (x & ((1ULL << 32) - 1)); }
  82              		.loc 1 13 0
  83              		.cfi_startproc
  84              		@ args = 0, pretend = 0, frame = 8
  85              		@ frame_needed = 1, uses_anonymous_args = 0
  86              		@ link register save eliminated.
  87 0000 80B4     		push	{r7}
  88              	.LCFI0:
  89              		.cfi_def_cfa_offset 4
  90              		.cfi_offset 7, -4
  91 0002 83B0     		sub	sp, sp, #12
  92              	.LCFI1:
  93              		.cfi_def_cfa_offset 16
  94 0004 00AF     		add	r7, sp, #0
  95              	.LCFI2:
  96              		.cfi_def_cfa_register 7
  97 0006 C7E90001 		strd	r0, [r7]
  98              		.loc 1 13 0
  99 000a 3B68     		ldr	r3, [r7, #0]
 100 000c 1846     		mov	r0, r3
 101 000e 07F10C07 		add	r7, r7, #12
 102 0012 BD46     		mov	sp, r7
 103 0014 80BC     		pop	{r7}
 104 0016 7047     		bx	lr
 105              		.cfi_endproc
 106              	.LFE9:
 108              		.align	2
 109              		.thumb
 110              		.thumb_func
 112              	int64_add:
 113              	.LFB10:
  14:../libfixmath/int64.h **** 
  15:../libfixmath/int64.h **** static inline int64_t int64_add(int64_t x, int64_t y)   { return (x + y);  }
 114              		.loc 1 15 0
 115              		.cfi_startproc
 116              		@ args = 0, pretend = 0, frame = 16
 117              		@ frame_needed = 1, uses_anonymous_args = 0
 118              		@ link register save eliminated.
 119 0018 80B4     		push	{r7}
 120              	.LCFI3:
 121              		.cfi_def_cfa_offset 4
 122              		.cfi_offset 7, -4
 123 001a 85B0     		sub	sp, sp, #20
 124              	.LCFI4:
 125              		.cfi_def_cfa_offset 24
 126 001c 00AF     		add	r7, sp, #0
 127              	.LCFI5:
 128              		.cfi_def_cfa_register 7
 129 001e C7E90201 		strd	r0, [r7, #8]
 130 0022 C7E90023 		strd	r2, [r7]
 131              		.loc 1 15 0
 132 0026 D7E90201 		ldrd	r0, [r7, #8]
 133 002a D7E90023 		ldrd	r2, [r7]
 134 002e 1218     		adds	r2, r2, r0
 135 0030 43EB0103 		adc	r3, r3, r1
 136 0034 1046     		mov	r0, r2
 137 0036 1946     		mov	r1, r3
 138 0038 07F11407 		add	r7, r7, #20
 139 003c BD46     		mov	sp, r7
 140 003e 80BC     		pop	{r7}
 141 0040 7047     		bx	lr
 142              		.cfi_endproc
 143              	.LFE10:
 145 0042 00BF     		.align	2
 146              		.thumb
 147              		.thumb_func
 149              	int64_shift:
 150              	.LFB13:
  16:../libfixmath/int64.h **** static inline int64_t int64_neg(int64_t x)              { return (-x);     }
  17:../libfixmath/int64.h **** static inline int64_t int64_sub(int64_t x, int64_t y)   { return (x - y);  }
  18:../libfixmath/int64.h **** static inline int64_t int64_shift(int64_t x, int8_t y)  { return (y < 0 ? (x >> -y) : (x << y)); }
 151              		.loc 1 18 0
 152              		.cfi_startproc
 153              		@ args = 0, pretend = 0, frame = 16
 154              		@ frame_needed = 1, uses_anonymous_args = 0
 155              		@ link register save eliminated.
 156 0044 F0B4     		push	{r4, r5, r6, r7}
 157              	.LCFI6:
 158              		.cfi_def_cfa_offset 16
 159              		.cfi_offset 7, -4
 160              		.cfi_offset 6, -8
 161              		.cfi_offset 5, -12
 162              		.cfi_offset 4, -16
 163 0046 84B0     		sub	sp, sp, #16
 164              	.LCFI7:
 165              		.cfi_def_cfa_offset 32
 166 0048 00AF     		add	r7, sp, #0
 167              	.LCFI8:
 168              		.cfi_def_cfa_register 7
 169 004a C7E90201 		strd	r0, [r7, #8]
 170 004e 1346     		mov	r3, r2
 171 0050 FB71     		strb	r3, [r7, #7]
 172              		.loc 1 18 0
 173 0052 97F90730 		ldrsb	r3, [r7, #7]
 174 0056 002B     		cmp	r3, #0
 175 0058 18DA     		bge	.L4
 176              		.loc 1 18 0 is_stmt 0 discriminator 1
 177 005a 97F90730 		ldrsb	r3, [r7, #7]
 178 005e C3F10003 		rsb	r3, r3, #0
 179 0062 A3F12002 		sub	r2, r3, #32
 180 0066 F968     		ldr	r1, [r7, #12]
 181 0068 41FA02F1 		asr	r1, r1, r2
 182 006c C3F12000 		rsb	r0, r3, #32
 183 0070 FE68     		ldr	r6, [r7, #12]
 184 0072 06FA00F0 		lsl	r0, r6, r0
 185 0076 BE68     		ldr	r6, [r7, #8]
 186 0078 26FA03F4 		lsr	r4, r6, r3
 187 007c 0443     		orrs	r4, r4, r0
 188 007e 002A     		cmp	r2, #0
 189 0080 A8BF     		it	ge
 190 0082 0C46     		movge	r4, r1
 191 0084 FA68     		ldr	r2, [r7, #12]
 192 0086 42FA03F5 		asr	r5, r2, r3
 193 008a 15E0     		b	.L5
 194              	.L4:
 195              		.loc 1 18 0 discriminator 2
 196 008c 97F90730 		ldrsb	r3, [r7, #7]
 197 0090 A3F12002 		sub	r2, r3, #32
 198 0094 B968     		ldr	r1, [r7, #8]
 199 0096 01FA02F1 		lsl	r1, r1, r2
 200 009a C3F12000 		rsb	r0, r3, #32
 201 009e BE68     		ldr	r6, [r7, #8]
 202 00a0 26FA00F0 		lsr	r0, r6, r0
 203 00a4 FE68     		ldr	r6, [r7, #12]
 204 00a6 06FA03F5 		lsl	r5, r6, r3
 205 00aa 0543     		orrs	r5, r5, r0
 206 00ac 002A     		cmp	r2, #0
 207 00ae A8BF     		it	ge
 208 00b0 0D46     		movge	r5, r1
 209 00b2 BA68     		ldr	r2, [r7, #8]
 210 00b4 02FA03F4 		lsl	r4, r2, r3
 211              	.L5:
 212              		.loc 1 18 0 discriminator 3
 213 00b8 2246     		mov	r2, r4
 214 00ba 2B46     		mov	r3, r5
 215 00bc 1046     		mov	r0, r2
 216 00be 1946     		mov	r1, r3
 217 00c0 07F11007 		add	r7, r7, #16
 218 00c4 BD46     		mov	sp, r7
 219 00c6 F0BC     		pop	{r4, r5, r6, r7}
 220 00c8 7047     		bx	lr
 221              		.cfi_endproc
 222              	.LFE13:
 224 00ca 00BF     		.align	2
 225              		.thumb
 226              		.thumb_func
 228              	int64_mul_i32_i32:
 229              	.LFB14:
  19:../libfixmath/int64.h **** 
  20:../libfixmath/int64.h **** static inline int64_t int64_mul_i32_i32(int32_t x, int32_t y) { return (x * y);  }
 230              		.loc 1 20 0 is_stmt 1
 231              		.cfi_startproc
 232              		@ args = 0, pretend = 0, frame = 8
 233              		@ frame_needed = 1, uses_anonymous_args = 0
 234              		@ link register save eliminated.
 235 00cc 80B4     		push	{r7}
 236              	.LCFI9:
 237              		.cfi_def_cfa_offset 4
 238              		.cfi_offset 7, -4
 239 00ce 83B0     		sub	sp, sp, #12
 240              	.LCFI10:
 241              		.cfi_def_cfa_offset 16
 242 00d0 00AF     		add	r7, sp, #0
 243              	.LCFI11:
 244              		.cfi_def_cfa_register 7
 245 00d2 7860     		str	r0, [r7, #4]
 246 00d4 3960     		str	r1, [r7, #0]
 247              		.loc 1 20 0
 248 00d6 7B68     		ldr	r3, [r7, #4]
 249 00d8 3A68     		ldr	r2, [r7, #0]
 250 00da 02FB03F1 		mul	r1, r2, r3
 251 00de 0A46     		mov	r2, r1
 252 00e0 4FEAE273 		asr	r3, r2, #31
 253 00e4 1046     		mov	r0, r2
 254 00e6 1946     		mov	r1, r3
 255 00e8 07F10C07 		add	r7, r7, #12
 256 00ec BD46     		mov	sp, r7
 257 00ee 80BC     		pop	{r7}
 258 00f0 7047     		bx	lr
 259              		.cfi_endproc
 260              	.LFE14:
 262 00f2 00BF     		.align	2
 263              		.global	fix16_add
 264              		.thumb
 265              		.thumb_func
 267              	fix16_add:
 268              	.LFB23:
 269              		.file 2 "../libfixmath/fix16.c"
   1:../libfixmath/fix16.c **** #include "fix16.h"
   2:../libfixmath/fix16.c **** #include "int64.h"
   3:../libfixmath/fix16.c **** 
   4:../libfixmath/fix16.c **** 
   5:../libfixmath/fix16.c **** /* Subtraction and addition with overflow detection.
   6:../libfixmath/fix16.c ****  * The versions without overflow detection are inlined in the header.
   7:../libfixmath/fix16.c ****  */
   8:../libfixmath/fix16.c **** #ifndef FIXMATH_NO_OVERFLOW
   9:../libfixmath/fix16.c **** fix16_t fix16_add(fix16_t a, fix16_t b)
  10:../libfixmath/fix16.c **** {
 270              		.loc 2 10 0
 271              		.cfi_startproc
 272              		@ args = 0, pretend = 0, frame = 24
 273              		@ frame_needed = 1, uses_anonymous_args = 0
 274              		@ link register save eliminated.
 275 00f4 80B4     		push	{r7}
 276              	.LCFI12:
 277              		.cfi_def_cfa_offset 4
 278              		.cfi_offset 7, -4
 279 00f6 87B0     		sub	sp, sp, #28
 280              	.LCFI13:
 281              		.cfi_def_cfa_offset 32
 282 00f8 00AF     		add	r7, sp, #0
 283              	.LCFI14:
 284              		.cfi_def_cfa_register 7
 285 00fa 7860     		str	r0, [r7, #4]
 286 00fc 3960     		str	r1, [r7, #0]
  11:../libfixmath/fix16.c ****   // Use unsigned integers because overflow with signed integers is
  12:../libfixmath/fix16.c ****   // an undefined operation (http://www.airs.com/blog/archives/120).
  13:../libfixmath/fix16.c ****   uint32_t _a = a, _b = b;
 287              		.loc 2 13 0
 288 00fe 7B68     		ldr	r3, [r7, #4]
 289 0100 7B61     		str	r3, [r7, #20]
 290 0102 3B68     		ldr	r3, [r7, #0]
 291 0104 3B61     		str	r3, [r7, #16]
  14:../libfixmath/fix16.c ****   uint32_t sum = _a + _b;
 292              		.loc 2 14 0
 293 0106 7A69     		ldr	r2, [r7, #20]
 294 0108 3B69     		ldr	r3, [r7, #16]
 295 010a D318     		adds	r3, r2, r3
 296 010c FB60     		str	r3, [r7, #12]
  15:../libfixmath/fix16.c **** 
  16:../libfixmath/fix16.c ****   // Overflow can only happen if sign of a == sign of b, and then
  17:../libfixmath/fix16.c ****   // it causes sign of sum != sign of a.
  18:../libfixmath/fix16.c ****   if (!((_a ^ _b) & 0x80000000) && ((_a ^ sum) & 0x80000000))
 297              		.loc 2 18 0
 298 010e 7A69     		ldr	r2, [r7, #20]
 299 0110 3B69     		ldr	r3, [r7, #16]
 300 0112 5340     		eors	r3, r3, r2
 301 0114 002B     		cmp	r3, #0
 302 0116 0ADB     		blt	.L8
 303              		.loc 2 18 0 is_stmt 0 discriminator 1
 304 0118 7A69     		ldr	r2, [r7, #20]
 305 011a FB68     		ldr	r3, [r7, #12]
 306 011c 5340     		eors	r3, r3, r2
 307 011e 002B     		cmp	r3, #0
 308 0120 05DA     		bge	.L8
  19:../libfixmath/fix16.c ****     return fix16_overflow;
 309              		.loc 2 19 0 is_stmt 1
 310 0122 40F20003 		movw	r3, #:lower16:fix16_overflow
 311 0126 C0F20003 		movt	r3, #:upper16:fix16_overflow
 312 012a 1B68     		ldr	r3, [r3, #0]
 313 012c 00E0     		b	.L9
 314              	.L8:
  20:../libfixmath/fix16.c ****   
  21:../libfixmath/fix16.c ****   return sum;
 315              		.loc 2 21 0
 316 012e FB68     		ldr	r3, [r7, #12]
 317              	.L9:
  22:../libfixmath/fix16.c **** }
 318              		.loc 2 22 0
 319 0130 1846     		mov	r0, r3
 320 0132 07F11C07 		add	r7, r7, #28
 321 0136 BD46     		mov	sp, r7
 322 0138 80BC     		pop	{r7}
 323 013a 7047     		bx	lr
 324              		.cfi_endproc
 325              	.LFE23:
 327              		.align	2
 328              		.global	fix16_sub
 329              		.thumb
 330              		.thumb_func
 332              	fix16_sub:
 333              	.LFB24:
  23:../libfixmath/fix16.c **** 
  24:../libfixmath/fix16.c **** fix16_t fix16_sub(fix16_t a, fix16_t b)
  25:../libfixmath/fix16.c **** {
 334              		.loc 2 25 0
 335              		.cfi_startproc
 336              		@ args = 0, pretend = 0, frame = 24
 337              		@ frame_needed = 1, uses_anonymous_args = 0
 338              		@ link register save eliminated.
 339 013c 80B4     		push	{r7}
 340              	.LCFI15:
 341              		.cfi_def_cfa_offset 4
 342              		.cfi_offset 7, -4
 343 013e 87B0     		sub	sp, sp, #28
 344              	.LCFI16:
 345              		.cfi_def_cfa_offset 32
 346 0140 00AF     		add	r7, sp, #0
 347              	.LCFI17:
 348              		.cfi_def_cfa_register 7
 349 0142 7860     		str	r0, [r7, #4]
 350 0144 3960     		str	r1, [r7, #0]
  26:../libfixmath/fix16.c ****   uint32_t _a = a, _b = b;
 351              		.loc 2 26 0
 352 0146 7B68     		ldr	r3, [r7, #4]
 353 0148 7B61     		str	r3, [r7, #20]
 354 014a 3B68     		ldr	r3, [r7, #0]
 355 014c 3B61     		str	r3, [r7, #16]
  27:../libfixmath/fix16.c ****   uint32_t diff = _a - _b;
 356              		.loc 2 27 0
 357 014e 7A69     		ldr	r2, [r7, #20]
 358 0150 3B69     		ldr	r3, [r7, #16]
 359 0152 D31A     		subs	r3, r2, r3
 360 0154 FB60     		str	r3, [r7, #12]
  28:../libfixmath/fix16.c **** 
  29:../libfixmath/fix16.c ****   // Overflow can only happen if sign of a != sign of b, and then
  30:../libfixmath/fix16.c ****   // it causes sign of diff != sign of a.
  31:../libfixmath/fix16.c ****   if (((_a ^ _b) & 0x80000000) && ((_a ^ diff) & 0x80000000))
 361              		.loc 2 31 0
 362 0156 7A69     		ldr	r2, [r7, #20]
 363 0158 3B69     		ldr	r3, [r7, #16]
 364 015a 5340     		eors	r3, r3, r2
 365 015c 002B     		cmp	r3, #0
 366 015e 0ADA     		bge	.L11
 367              		.loc 2 31 0 is_stmt 0 discriminator 1
 368 0160 7A69     		ldr	r2, [r7, #20]
 369 0162 FB68     		ldr	r3, [r7, #12]
 370 0164 5340     		eors	r3, r3, r2
 371 0166 002B     		cmp	r3, #0
 372 0168 05DA     		bge	.L11
  32:../libfixmath/fix16.c ****     return fix16_overflow;
 373              		.loc 2 32 0 is_stmt 1
 374 016a 40F20003 		movw	r3, #:lower16:fix16_overflow
 375 016e C0F20003 		movt	r3, #:upper16:fix16_overflow
 376 0172 1B68     		ldr	r3, [r3, #0]
 377 0174 00E0     		b	.L12
 378              	.L11:
  33:../libfixmath/fix16.c ****   
  34:../libfixmath/fix16.c ****   return diff;
 379              		.loc 2 34 0
 380 0176 FB68     		ldr	r3, [r7, #12]
 381              	.L12:
  35:../libfixmath/fix16.c **** }
 382              		.loc 2 35 0
 383 0178 1846     		mov	r0, r3
 384 017a 07F11C07 		add	r7, r7, #28
 385 017e BD46     		mov	sp, r7
 386 0180 80BC     		pop	{r7}
 387 0182 7047     		bx	lr
 388              		.cfi_endproc
 389              	.LFE24:
 391              		.align	2
 392              		.global	fix16_sadd
 393              		.thumb
 394              		.thumb_func
 396              	fix16_sadd:
 397              	.LFB25:
  36:../libfixmath/fix16.c **** 
  37:../libfixmath/fix16.c **** /* Saturating arithmetic */
  38:../libfixmath/fix16.c **** fix16_t fix16_sadd(fix16_t a, fix16_t b)
  39:../libfixmath/fix16.c **** {
 398              		.loc 2 39 0
 399              		.cfi_startproc
 400              		@ args = 0, pretend = 0, frame = 16
 401              		@ frame_needed = 1, uses_anonymous_args = 0
 402 0184 80B5     		push	{r7, lr}
 403              	.LCFI18:
 404              		.cfi_def_cfa_offset 8
 405              		.cfi_offset 14, -4
 406              		.cfi_offset 7, -8
 407 0186 84B0     		sub	sp, sp, #16
 408              	.LCFI19:
 409              		.cfi_def_cfa_offset 24
 410 0188 00AF     		add	r7, sp, #0
 411              	.LCFI20:
 412              		.cfi_def_cfa_register 7
 413 018a 7860     		str	r0, [r7, #4]
 414 018c 3960     		str	r1, [r7, #0]
  40:../libfixmath/fix16.c ****   fix16_t result = fix16_add(a, b);
 415              		.loc 2 40 0
 416 018e 7868     		ldr	r0, [r7, #4]
 417 0190 3968     		ldr	r1, [r7, #0]
 418 0192 FFF7FEFF 		bl	fix16_add
 419 0196 F860     		str	r0, [r7, #12]
  41:../libfixmath/fix16.c **** 
  42:../libfixmath/fix16.c ****   if (result == fix16_overflow)
 420              		.loc 2 42 0
 421 0198 40F20003 		movw	r3, #:lower16:fix16_overflow
 422 019c C0F20003 		movt	r3, #:upper16:fix16_overflow
 423 01a0 1B68     		ldr	r3, [r3, #0]
 424 01a2 FA68     		ldr	r2, [r7, #12]
 425 01a4 9A42     		cmp	r2, r3
 426 01a6 0ED1     		bne	.L14
  43:../libfixmath/fix16.c ****     return (a > 0) ? fix16_max : fix16_min;
 427              		.loc 2 43 0
 428 01a8 7B68     		ldr	r3, [r7, #4]
 429 01aa 002B     		cmp	r3, #0
 430 01ac 05DD     		ble	.L15
 431              		.loc 2 43 0 is_stmt 0 discriminator 1
 432 01ae 40F20003 		movw	r3, #:lower16:fix16_max
 433 01b2 C0F20003 		movt	r3, #:upper16:fix16_max
 434 01b6 1B68     		ldr	r3, [r3, #0]
 435 01b8 04E0     		b	.L16
 436              	.L15:
 437              		.loc 2 43 0 discriminator 2
 438 01ba 40F20003 		movw	r3, #:lower16:fix16_min
 439 01be C0F20003 		movt	r3, #:upper16:fix16_min
 440 01c2 1B68     		ldr	r3, [r3, #0]
 441              	.L16:
 442              		.loc 2 43 0 discriminator 3
 443 01c4 00E0     		b	.L17
 444              	.L14:
  44:../libfixmath/fix16.c **** 
  45:../libfixmath/fix16.c ****   return result;
 445              		.loc 2 45 0 is_stmt 1
 446 01c6 FB68     		ldr	r3, [r7, #12]
 447              	.L17:
  46:../libfixmath/fix16.c **** }  
 448              		.loc 2 46 0
 449 01c8 1846     		mov	r0, r3
 450 01ca 07F11007 		add	r7, r7, #16
 451 01ce BD46     		mov	sp, r7
 452 01d0 80BD     		pop	{r7, pc}
 453              		.cfi_endproc
 454              	.LFE25:
 456 01d2 00BF     		.align	2
 457              		.global	fix16_ssub
 458              		.thumb
 459              		.thumb_func
 461              	fix16_ssub:
 462              	.LFB26:
  47:../libfixmath/fix16.c **** 
  48:../libfixmath/fix16.c **** fix16_t fix16_ssub(fix16_t a, fix16_t b)
  49:../libfixmath/fix16.c **** {
 463              		.loc 2 49 0
 464              		.cfi_startproc
 465              		@ args = 0, pretend = 0, frame = 16
 466              		@ frame_needed = 1, uses_anonymous_args = 0
 467 01d4 80B5     		push	{r7, lr}
 468              	.LCFI21:
 469              		.cfi_def_cfa_offset 8
 470              		.cfi_offset 14, -4
 471              		.cfi_offset 7, -8
 472 01d6 84B0     		sub	sp, sp, #16
 473              	.LCFI22:
 474              		.cfi_def_cfa_offset 24
 475 01d8 00AF     		add	r7, sp, #0
 476              	.LCFI23:
 477              		.cfi_def_cfa_register 7
 478 01da 7860     		str	r0, [r7, #4]
 479 01dc 3960     		str	r1, [r7, #0]
  50:../libfixmath/fix16.c ****   fix16_t result = fix16_sub(a, b);
 480              		.loc 2 50 0
 481 01de 7868     		ldr	r0, [r7, #4]
 482 01e0 3968     		ldr	r1, [r7, #0]
 483 01e2 FFF7FEFF 		bl	fix16_sub
 484 01e6 F860     		str	r0, [r7, #12]
  51:../libfixmath/fix16.c **** 
  52:../libfixmath/fix16.c ****   if (result == fix16_overflow)
 485              		.loc 2 52 0
 486 01e8 40F20003 		movw	r3, #:lower16:fix16_overflow
 487 01ec C0F20003 		movt	r3, #:upper16:fix16_overflow
 488 01f0 1B68     		ldr	r3, [r3, #0]
 489 01f2 FA68     		ldr	r2, [r7, #12]
 490 01f4 9A42     		cmp	r2, r3
 491 01f6 0ED1     		bne	.L19
  53:../libfixmath/fix16.c ****     return (a > 0) ? fix16_max : fix16_min;
 492              		.loc 2 53 0
 493 01f8 7B68     		ldr	r3, [r7, #4]
 494 01fa 002B     		cmp	r3, #0
 495 01fc 05DD     		ble	.L20
 496              		.loc 2 53 0 is_stmt 0 discriminator 1
 497 01fe 40F20003 		movw	r3, #:lower16:fix16_max
 498 0202 C0F20003 		movt	r3, #:upper16:fix16_max
 499 0206 1B68     		ldr	r3, [r3, #0]
 500 0208 04E0     		b	.L21
 501              	.L20:
 502              		.loc 2 53 0 discriminator 2
 503 020a 40F20003 		movw	r3, #:lower16:fix16_min
 504 020e C0F20003 		movt	r3, #:upper16:fix16_min
 505 0212 1B68     		ldr	r3, [r3, #0]
 506              	.L21:
 507              		.loc 2 53 0 discriminator 3
 508 0214 00E0     		b	.L22
 509              	.L19:
  54:../libfixmath/fix16.c **** 
  55:../libfixmath/fix16.c ****   return result;
 510              		.loc 2 55 0 is_stmt 1
 511 0216 FB68     		ldr	r3, [r7, #12]
 512              	.L22:
  56:../libfixmath/fix16.c **** }
 513              		.loc 2 56 0
 514 0218 1846     		mov	r0, r3
 515 021a 07F11007 		add	r7, r7, #16
 516 021e BD46     		mov	sp, r7
 517 0220 80BD     		pop	{r7, pc}
 518              		.cfi_endproc
 519              	.LFE26:
 521 0222 00BF     		.align	2
 522              		.global	fix16_mul
 523              		.thumb
 524              		.thumb_func
 526              	fix16_mul:
 527              	.LFB27:
  57:../libfixmath/fix16.c **** #endif
  58:../libfixmath/fix16.c **** 
  59:../libfixmath/fix16.c **** 
  60:../libfixmath/fix16.c **** 
  61:../libfixmath/fix16.c **** /* 64-bit implementation for fix16_mul. Fastest version for e.g. ARM Cortex M3.
  62:../libfixmath/fix16.c ****  * Performs a 32*32 -> 64bit multiplication. The middle 32 bits are the result,
  63:../libfixmath/fix16.c ****  * bottom 16 bits are used for rounding, and upper 16 bits are used for overflow
  64:../libfixmath/fix16.c ****  * detection.
  65:../libfixmath/fix16.c ****  */
  66:../libfixmath/fix16.c ****  
  67:../libfixmath/fix16.c **** #if !defined(FIXMATH_NO_64BIT) && !defined(FIXMATH_OPTIMIZE_8BIT)
  68:../libfixmath/fix16.c **** fix16_t fix16_mul(fix16_t inArg0, fix16_t inArg1)
  69:../libfixmath/fix16.c **** {
 528              		.loc 2 69 0
 529              		.cfi_startproc
 530              		@ args = 0, pretend = 0, frame = 32
 531              		@ frame_needed = 1, uses_anonymous_args = 0
 532              		@ link register save eliminated.
 533 0224 2DE9B00F 		push	{r4, r5, r7, r8, r9, sl, fp}
 534              	.LCFI24:
 535              		.cfi_def_cfa_offset 28
 536              		.cfi_offset 11, -4
 537              		.cfi_offset 10, -8
 538              		.cfi_offset 9, -12
 539              		.cfi_offset 8, -16
 540              		.cfi_offset 7, -20
 541              		.cfi_offset 5, -24
 542              		.cfi_offset 4, -28
 543 0228 89B0     		sub	sp, sp, #36
 544              	.LCFI25:
 545              		.cfi_def_cfa_offset 64
 546 022a 00AF     		add	r7, sp, #0
 547              	.LCFI26:
 548              		.cfi_def_cfa_register 7
 549 022c F860     		str	r0, [r7, #12]
 550 022e B960     		str	r1, [r7, #8]
  70:../libfixmath/fix16.c ****   int64_t product = (int64_t)inArg0 * inArg1;
 551              		.loc 2 70 0
 552 0230 FB68     		ldr	r3, [r7, #12]
 553 0232 1C46     		mov	r4, r3
 554 0234 4FEAE475 		asr	r5, r4, #31
 555 0238 B968     		ldr	r1, [r7, #8]
 556 023a 0A46     		mov	r2, r1
 557 023c 4FEAE273 		asr	r3, r2, #31
 558 0240 02FB05F0 		mul	r0, r2, r5
 559 0244 04FB03F1 		mul	r1, r4, r3
 560 0248 4118     		adds	r1, r0, r1
 561 024a A4FB0223 		umull	r2, r3, r4, r2
 562 024e C918     		adds	r1, r1, r3
 563 0250 0B46     		mov	r3, r1
 564 0252 C7E90623 		strd	r2, [r7, #24]
 565 0256 C7E90623 		strd	r2, [r7, #24]
  71:../libfixmath/fix16.c ****   
  72:../libfixmath/fix16.c ****   #ifndef FIXMATH_NO_OVERFLOW
  73:../libfixmath/fix16.c ****   // The upper 17 bits should all be the same (the sign).
  74:../libfixmath/fix16.c ****   uint32_t upper = (product >> 47);
 566              		.loc 2 74 0
 567 025a FB69     		ldr	r3, [r7, #28]
 568 025c 4FEAE333 		asr	r3, r3, #15
 569 0260 3B60     		str	r3, [r7, #0]
 570 0262 FB69     		ldr	r3, [r7, #28]
 571 0264 4FEAE373 		asr	r3, r3, #31
 572 0268 7B60     		str	r3, [r7, #4]
 573 026a 3B68     		ldr	r3, [r7, #0]
 574 026c 7B61     		str	r3, [r7, #20]
  75:../libfixmath/fix16.c ****   #endif
  76:../libfixmath/fix16.c ****   
  77:../libfixmath/fix16.c ****   if (product < 0)
 575              		.loc 2 77 0
 576 026e D7E90623 		ldrd	r2, [r7, #24]
 577 0272 002A     		cmp	r2, #0
 578 0274 73F10001 		sbcs	r1, r3, #0
 579 0278 15DA     		bge	.L24
  78:../libfixmath/fix16.c ****   {
  79:../libfixmath/fix16.c ****     #ifndef FIXMATH_NO_OVERFLOW
  80:../libfixmath/fix16.c ****     if (~upper)
 580              		.loc 2 80 0
 581 027a 7B69     		ldr	r3, [r7, #20]
 582 027c B3F1FF3F 		cmp	r3, #-1
 583 0280 05D0     		beq	.L25
  81:../libfixmath/fix16.c ****         return fix16_overflow;
 584              		.loc 2 81 0
 585 0282 40F20003 		movw	r3, #:lower16:fix16_overflow
 586 0286 C0F20003 		movt	r3, #:upper16:fix16_overflow
 587 028a 1B68     		ldr	r3, [r3, #0]
 588 028c 38E0     		b	.L26
 589              	.L25:
  82:../libfixmath/fix16.c ****     #endif
  83:../libfixmath/fix16.c ****     
  84:../libfixmath/fix16.c ****     #ifndef FIXMATH_NO_ROUNDING
  85:../libfixmath/fix16.c ****     // This adjustment is required in order to round -1/2 correctly
  86:../libfixmath/fix16.c ****     product--;
 590              		.loc 2 86 0
 591 028e D7E90601 		ldrd	r0, [r7, #24]
 592 0292 4FF0FF32 		mov	r2, #-1
 593 0296 4FF0FF33 		mov	r3, #-1
 594 029a 1218     		adds	r2, r2, r0
 595 029c 43EB0103 		adc	r3, r3, r1
 596 02a0 C7E90623 		strd	r2, [r7, #24]
 597 02a4 08E0     		b	.L27
 598              	.L24:
  87:../libfixmath/fix16.c ****     #endif
  88:../libfixmath/fix16.c ****   }
  89:../libfixmath/fix16.c ****   else
  90:../libfixmath/fix16.c ****   {
  91:../libfixmath/fix16.c ****     #ifndef FIXMATH_NO_OVERFLOW
  92:../libfixmath/fix16.c ****     if (upper)
 599              		.loc 2 92 0
 600 02a6 7B69     		ldr	r3, [r7, #20]
 601 02a8 002B     		cmp	r3, #0
 602 02aa 05D0     		beq	.L27
  93:../libfixmath/fix16.c ****         return fix16_overflow;
 603              		.loc 2 93 0
 604 02ac 40F20003 		movw	r3, #:lower16:fix16_overflow
 605 02b0 C0F20003 		movt	r3, #:upper16:fix16_overflow
 606 02b4 1B68     		ldr	r3, [r3, #0]
 607 02b6 23E0     		b	.L26
 608              	.L27:
  94:../libfixmath/fix16.c ****     #endif
  95:../libfixmath/fix16.c ****   }
  96:../libfixmath/fix16.c ****   
  97:../libfixmath/fix16.c ****   #ifdef FIXMATH_NO_ROUNDING
  98:../libfixmath/fix16.c ****   return product >> 16;
  99:../libfixmath/fix16.c ****   #else
 100:../libfixmath/fix16.c ****   fix16_t result = product >> 16;
 609              		.loc 2 100 0
 610 02b8 FB69     		ldr	r3, [r7, #28]
 611 02ba 4FEA0342 		lsl	r2, r3, #16
 612 02be BB69     		ldr	r3, [r7, #24]
 613 02c0 4FEA134A 		lsr	sl, r3, #16
 614 02c4 42EA0A0A 		orr	sl, r2, sl
 615 02c8 FB69     		ldr	r3, [r7, #28]
 616 02ca 4FEA234B 		asr	fp, r3, #16
 617 02ce 5346     		mov	r3, sl
 618 02d0 3B61     		str	r3, [r7, #16]
 101:../libfixmath/fix16.c ****   result += (product & 0x8000) >> 15;
 619              		.loc 2 101 0
 620 02d2 D7E90601 		ldrd	r0, [r7, #24]
 621 02d6 4FF40042 		mov	r2, #32768
 622 02da 4FF00003 		mov	r3, #0
 623 02de 02EA0002 		and	r2, r2, r0
 624 02e2 03EA0103 		and	r3, r3, r1
 625 02e6 4FEA4341 		lsl	r1, r3, #17
 626 02ea 4FEAD238 		lsr	r8, r2, #15
 627 02ee 41EA0808 		orr	r8, r1, r8
 628 02f2 4FEAE339 		asr	r9, r3, #15
 629 02f6 4246     		mov	r2, r8
 630 02f8 3B69     		ldr	r3, [r7, #16]
 631 02fa D318     		adds	r3, r2, r3
 632 02fc 3B61     		str	r3, [r7, #16]
 102:../libfixmath/fix16.c ****   
 103:../libfixmath/fix16.c ****   return result;
 633              		.loc 2 103 0
 634 02fe 3B69     		ldr	r3, [r7, #16]
 635              	.L26:
 104:../libfixmath/fix16.c ****   #endif
 105:../libfixmath/fix16.c **** }
 636              		.loc 2 105 0
 637 0300 1846     		mov	r0, r3
 638 0302 07F12407 		add	r7, r7, #36
 639 0306 BD46     		mov	sp, r7
 640 0308 BDE8B00F 		pop	{r4, r5, r7, r8, r9, sl, fp}
 641 030c 7047     		bx	lr
 642              		.cfi_endproc
 643              	.LFE27:
 645 030e 00BF     		.align	2
 646              		.global	fix16_smul
 647              		.thumb
 648              		.thumb_func
 650              	fix16_smul:
 651              	.LFB28:
 106:../libfixmath/fix16.c **** #endif
 107:../libfixmath/fix16.c **** 
 108:../libfixmath/fix16.c **** /* 32-bit implementation of fix16_mul. Potentially fast on 16-bit processors,
 109:../libfixmath/fix16.c ****  * and this is a relatively good compromise for compilers that do not support
 110:../libfixmath/fix16.c ****  * uint64_t. Uses 16*16->32bit multiplications.
 111:../libfixmath/fix16.c ****  */
 112:../libfixmath/fix16.c **** #if defined(FIXMATH_NO_64BIT) && !defined(FIXMATH_OPTIMIZE_8BIT)
 113:../libfixmath/fix16.c **** fix16_t fix16_mul(fix16_t inArg0, fix16_t inArg1)
 114:../libfixmath/fix16.c **** {
 115:../libfixmath/fix16.c ****   // Each argument is divided to 16-bit parts.
 116:../libfixmath/fix16.c ****   //          AB
 117:../libfixmath/fix16.c ****   //      *   CD
 118:../libfixmath/fix16.c ****   // -----------
 119:../libfixmath/fix16.c ****   //          BD  16 * 16 -> 32 bit products
 120:../libfixmath/fix16.c ****   //         CB
 121:../libfixmath/fix16.c ****   //         AD
 122:../libfixmath/fix16.c ****   //        AC
 123:../libfixmath/fix16.c ****   //       |----| 64 bit product
 124:../libfixmath/fix16.c ****   int32_t A = (inArg0 >> 16), C = (inArg1 >> 16);
 125:../libfixmath/fix16.c ****   uint32_t B = (inArg0 & 0xFFFF), D = (inArg1 & 0xFFFF);
 126:../libfixmath/fix16.c ****   
 127:../libfixmath/fix16.c ****   int32_t AC = A*C;
 128:../libfixmath/fix16.c ****   int32_t AD_CB = A*D + C*B;
 129:../libfixmath/fix16.c ****   uint32_t BD = B*D;
 130:../libfixmath/fix16.c ****   
 131:../libfixmath/fix16.c ****   int32_t product_hi = AC + (AD_CB >> 16);
 132:../libfixmath/fix16.c ****   
 133:../libfixmath/fix16.c ****   // Handle carry from lower 32 bits to upper part of result.
 134:../libfixmath/fix16.c ****   uint32_t ad_cb_temp = AD_CB << 16;
 135:../libfixmath/fix16.c ****   uint32_t product_lo = BD + ad_cb_temp;
 136:../libfixmath/fix16.c ****   if (product_lo < BD)
 137:../libfixmath/fix16.c ****     product_hi++;
 138:../libfixmath/fix16.c ****   
 139:../libfixmath/fix16.c **** #ifndef FIXMATH_NO_OVERFLOW
 140:../libfixmath/fix16.c ****   // The upper 17 bits should all be the same (the sign).
 141:../libfixmath/fix16.c ****   if (product_hi >> 31 != product_hi >> 15)
 142:../libfixmath/fix16.c ****     return fix16_overflow;
 143:../libfixmath/fix16.c **** #endif
 144:../libfixmath/fix16.c ****   
 145:../libfixmath/fix16.c **** #ifdef FIXMATH_NO_ROUNDING
 146:../libfixmath/fix16.c ****   return (product_hi << 16) | (product_lo >> 16);
 147:../libfixmath/fix16.c **** #else
 148:../libfixmath/fix16.c ****   // Subtracting 0x8000 (= 0.5) and then using signed right shift
 149:../libfixmath/fix16.c ****   // achieves proper rounding to result-1, except in the corner
 150:../libfixmath/fix16.c ****   // case of negative numbers and lowest word = 0x8000.
 151:../libfixmath/fix16.c ****   // To handle that, we also have to subtract 1 for negative numbers.
 152:../libfixmath/fix16.c ****   uint32_t product_lo_tmp = product_lo;
 153:../libfixmath/fix16.c ****   product_lo -= 0x8000;
 154:../libfixmath/fix16.c ****   product_lo -= (uint32_t)product_hi >> 31;
 155:../libfixmath/fix16.c ****   if (product_lo > product_lo_tmp)
 156:../libfixmath/fix16.c ****     product_hi--;
 157:../libfixmath/fix16.c ****   
 158:../libfixmath/fix16.c ****   // Discard the lowest 16 bits. Note that this is not exactly the same
 159:../libfixmath/fix16.c ****   // as dividing by 0x10000. For example if product = -1, result will
 160:../libfixmath/fix16.c ****   // also be -1 and not 0. This is compensated by adding +1 to the result
 161:../libfixmath/fix16.c ****   // and compensating this in turn in the rounding above.
 162:../libfixmath/fix16.c ****   fix16_t result = (product_hi << 16) | (product_lo >> 16);
 163:../libfixmath/fix16.c ****   result += 1;
 164:../libfixmath/fix16.c ****   return result;
 165:../libfixmath/fix16.c **** #endif
 166:../libfixmath/fix16.c **** }
 167:../libfixmath/fix16.c **** #endif
 168:../libfixmath/fix16.c **** 
 169:../libfixmath/fix16.c **** /* 8-bit implementation of fix16_mul. Fastest on e.g. Atmel AVR.
 170:../libfixmath/fix16.c ****  * Uses 8*8->16bit multiplications, and also skips any bytes that
 171:../libfixmath/fix16.c ****  * are zero.
 172:../libfixmath/fix16.c ****  */
 173:../libfixmath/fix16.c **** #if defined(FIXMATH_OPTIMIZE_8BIT)
 174:../libfixmath/fix16.c **** fix16_t fix16_mul(fix16_t inArg0, fix16_t inArg1)
 175:../libfixmath/fix16.c **** {
 176:../libfixmath/fix16.c ****   uint32_t _a = (inArg0 >= 0) ? inArg0 : (-inArg0);
 177:../libfixmath/fix16.c ****   uint32_t _b = (inArg1 >= 0) ? inArg1 : (-inArg1);
 178:../libfixmath/fix16.c ****   
 179:../libfixmath/fix16.c ****   uint8_t va[4] = {_a, (_a >> 8), (_a >> 16), (_a >> 24)};
 180:../libfixmath/fix16.c ****   uint8_t vb[4] = {_b, (_b >> 8), (_b >> 16), (_b >> 24)};
 181:../libfixmath/fix16.c ****   
 182:../libfixmath/fix16.c ****   uint32_t low = 0;
 183:../libfixmath/fix16.c ****   uint32_t mid = 0;
 184:../libfixmath/fix16.c ****   
 185:../libfixmath/fix16.c ****   // Result column i depends on va[0..i] and vb[i..0]
 186:../libfixmath/fix16.c **** 
 187:../libfixmath/fix16.c ****   #ifndef FIXMATH_NO_OVERFLOW
 188:../libfixmath/fix16.c ****   // i = 6
 189:../libfixmath/fix16.c ****   if (va[3] && vb[3]) return fix16_overflow;
 190:../libfixmath/fix16.c ****   #endif
 191:../libfixmath/fix16.c ****   
 192:../libfixmath/fix16.c ****   // i = 5
 193:../libfixmath/fix16.c ****   if (va[2] && vb[3]) mid += (uint16_t)va[2] * vb[3];
 194:../libfixmath/fix16.c ****   if (va[3] && vb[2]) mid += (uint16_t)va[3] * vb[2];
 195:../libfixmath/fix16.c ****   mid <<= 8;
 196:../libfixmath/fix16.c ****   
 197:../libfixmath/fix16.c ****   // i = 4
 198:../libfixmath/fix16.c ****   if (va[1] && vb[3]) mid += (uint16_t)va[1] * vb[3];
 199:../libfixmath/fix16.c ****   if (va[2] && vb[2]) mid += (uint16_t)va[2] * vb[2];
 200:../libfixmath/fix16.c ****   if (va[3] && vb[1]) mid += (uint16_t)va[3] * vb[1];
 201:../libfixmath/fix16.c ****   
 202:../libfixmath/fix16.c ****   #ifndef FIXMATH_NO_OVERFLOW
 203:../libfixmath/fix16.c ****   if (mid & 0xFF000000) return fix16_overflow;
 204:../libfixmath/fix16.c ****   #endif
 205:../libfixmath/fix16.c ****   mid <<= 8;
 206:../libfixmath/fix16.c ****   
 207:../libfixmath/fix16.c ****   // i = 3
 208:../libfixmath/fix16.c ****   if (va[0] && vb[3]) mid += (uint16_t)va[0] * vb[3];
 209:../libfixmath/fix16.c ****   if (va[1] && vb[2]) mid += (uint16_t)va[1] * vb[2];
 210:../libfixmath/fix16.c ****   if (va[2] && vb[1]) mid += (uint16_t)va[2] * vb[1];
 211:../libfixmath/fix16.c ****   if (va[3] && vb[0]) mid += (uint16_t)va[3] * vb[0];
 212:../libfixmath/fix16.c ****   
 213:../libfixmath/fix16.c ****   #ifndef FIXMATH_NO_OVERFLOW
 214:../libfixmath/fix16.c ****   if (mid & 0xFF000000) return fix16_overflow;
 215:../libfixmath/fix16.c ****   #endif
 216:../libfixmath/fix16.c ****   mid <<= 8;
 217:../libfixmath/fix16.c ****   
 218:../libfixmath/fix16.c ****   // i = 2
 219:../libfixmath/fix16.c ****   if (va[0] && vb[2]) mid += (uint16_t)va[0] * vb[2];
 220:../libfixmath/fix16.c ****   if (va[1] && vb[1]) mid += (uint16_t)va[1] * vb[1];
 221:../libfixmath/fix16.c ****   if (va[2] && vb[0]) mid += (uint16_t)va[2] * vb[0];    
 222:../libfixmath/fix16.c ****   
 223:../libfixmath/fix16.c ****   // i = 1
 224:../libfixmath/fix16.c ****   if (va[0] && vb[1]) low += (uint16_t)va[0] * vb[1];
 225:../libfixmath/fix16.c ****   if (va[1] && vb[0]) low += (uint16_t)va[1] * vb[0];
 226:../libfixmath/fix16.c ****   low <<= 8;
 227:../libfixmath/fix16.c ****   
 228:../libfixmath/fix16.c ****   // i = 0
 229:../libfixmath/fix16.c ****   if (va[0] && vb[0]) low += (uint16_t)va[0] * vb[0];
 230:../libfixmath/fix16.c ****   
 231:../libfixmath/fix16.c ****   #ifndef FIXMATH_NO_ROUNDING
 232:../libfixmath/fix16.c ****   low += 0x8000;
 233:../libfixmath/fix16.c ****   #endif
 234:../libfixmath/fix16.c ****   mid += (low >> 16);
 235:../libfixmath/fix16.c ****   
 236:../libfixmath/fix16.c ****   #ifndef FIXMATH_NO_OVERFLOW
 237:../libfixmath/fix16.c ****   if (mid & 0x80000000)
 238:../libfixmath/fix16.c ****     return fix16_overflow;
 239:../libfixmath/fix16.c ****   #endif
 240:../libfixmath/fix16.c ****   
 241:../libfixmath/fix16.c ****   fix16_t result = mid;
 242:../libfixmath/fix16.c ****   
 243:../libfixmath/fix16.c ****   /* Figure out the sign of result */
 244:../libfixmath/fix16.c ****   if ((inArg0 >= 0) != (inArg1 >= 0))
 245:../libfixmath/fix16.c ****   {
 246:../libfixmath/fix16.c ****     result = -result;
 247:../libfixmath/fix16.c ****   }
 248:../libfixmath/fix16.c ****   
 249:../libfixmath/fix16.c ****   return result;
 250:../libfixmath/fix16.c **** }
 251:../libfixmath/fix16.c **** #endif
 252:../libfixmath/fix16.c **** 
 253:../libfixmath/fix16.c **** #ifndef FIXMATH_NO_OVERFLOW
 254:../libfixmath/fix16.c **** /* Wrapper around fix16_mul to add saturating arithmetic. */
 255:../libfixmath/fix16.c **** fix16_t fix16_smul(fix16_t inArg0, fix16_t inArg1) {
 652              		.loc 2 255 0
 653              		.cfi_startproc
 654              		@ args = 0, pretend = 0, frame = 16
 655              		@ frame_needed = 1, uses_anonymous_args = 0
 656 0310 80B5     		push	{r7, lr}
 657              	.LCFI27:
 658              		.cfi_def_cfa_offset 8
 659              		.cfi_offset 14, -4
 660              		.cfi_offset 7, -8
 661 0312 84B0     		sub	sp, sp, #16
 662              	.LCFI28:
 663              		.cfi_def_cfa_offset 24
 664 0314 00AF     		add	r7, sp, #0
 665              	.LCFI29:
 666              		.cfi_def_cfa_register 7
 667 0316 7860     		str	r0, [r7, #4]
 668 0318 3960     		str	r1, [r7, #0]
 256:../libfixmath/fix16.c ****   fix16_t result = fix16_mul(inArg0, inArg1);
 669              		.loc 2 256 0
 670 031a 7868     		ldr	r0, [r7, #4]
 671 031c 3968     		ldr	r1, [r7, #0]
 672 031e FFF7FEFF 		bl	fix16_mul
 673 0322 F860     		str	r0, [r7, #12]
 257:../libfixmath/fix16.c ****   
 258:../libfixmath/fix16.c ****   if (result == fix16_overflow)
 674              		.loc 2 258 0
 675 0324 40F20003 		movw	r3, #:lower16:fix16_overflow
 676 0328 C0F20003 		movt	r3, #:upper16:fix16_overflow
 677 032c 1B68     		ldr	r3, [r3, #0]
 678 032e FA68     		ldr	r2, [r7, #12]
 679 0330 9A42     		cmp	r2, r3
 680 0332 19D1     		bne	.L29
 259:../libfixmath/fix16.c ****   {
 260:../libfixmath/fix16.c ****     if ((inArg0 >= 0) == (inArg1 >= 0))
 681              		.loc 2 260 0
 682 0334 7B68     		ldr	r3, [r7, #4]
 683 0336 4FEAD373 		lsr	r3, r3, #31
 684 033a DAB2     		uxtb	r2, r3
 685 033c 3B68     		ldr	r3, [r7, #0]
 686 033e 6FEA0303 		mvn	r3, r3
 687 0342 4FEAD373 		lsr	r3, r3, #31
 688 0346 DBB2     		uxtb	r3, r3
 689 0348 5340     		eors	r3, r3, r2
 690 034a DBB2     		uxtb	r3, r3
 691 034c 002B     		cmp	r3, #0
 692 034e 05D0     		beq	.L30
 261:../libfixmath/fix16.c ****       return fix16_max;
 693              		.loc 2 261 0
 694 0350 40F20003 		movw	r3, #:lower16:fix16_max
 695 0354 C0F20003 		movt	r3, #:upper16:fix16_max
 696 0358 1B68     		ldr	r3, [r3, #0]
 697 035a 06E0     		b	.L31
 698              	.L30:
 262:../libfixmath/fix16.c ****     else
 263:../libfixmath/fix16.c ****       return fix16_min;
 699              		.loc 2 263 0
 700 035c 40F20003 		movw	r3, #:lower16:fix16_min
 701 0360 C0F20003 		movt	r3, #:upper16:fix16_min
 702 0364 1B68     		ldr	r3, [r3, #0]
 703 0366 00E0     		b	.L31
 704              	.L29:
 264:../libfixmath/fix16.c ****   }
 265:../libfixmath/fix16.c ****   
 266:../libfixmath/fix16.c ****   return result;
 705              		.loc 2 266 0
 706 0368 FB68     		ldr	r3, [r7, #12]
 707              	.L31:
 267:../libfixmath/fix16.c **** }
 708              		.loc 2 267 0
 709 036a 1846     		mov	r0, r3
 710 036c 07F11007 		add	r7, r7, #16
 711 0370 BD46     		mov	sp, r7
 712 0372 80BD     		pop	{r7, pc}
 713              		.cfi_endproc
 714              	.LFE28:
 716              		.align	2
 717              		.global	fix16_div
 718              		.thumb
 719              		.thumb_func
 721              	fix16_div:
 722              	.LFB29:
 268:../libfixmath/fix16.c **** #endif
 269:../libfixmath/fix16.c **** 
 270:../libfixmath/fix16.c **** /* 32-bit implementation of fix16_div. Fastest version for e.g. ARM Cortex M3.
 271:../libfixmath/fix16.c ****  * Performs 32-bit divisions repeatedly to reduce the remainder. For this to
 272:../libfixmath/fix16.c ****  * be efficient, the processor has to have 32-bit hardware division.
 273:../libfixmath/fix16.c ****  */
 274:../libfixmath/fix16.c **** #if !defined(FIXMATH_OPTIMIZE_8BIT)
 275:../libfixmath/fix16.c **** #ifdef __GNUC__
 276:../libfixmath/fix16.c **** // Count leading zeros, using processor-specific instruction if available.
 277:../libfixmath/fix16.c **** #define clz(x) __builtin_clzl(x)
 278:../libfixmath/fix16.c **** #else
 279:../libfixmath/fix16.c **** static uint8_t clz(uint32_t x)
 280:../libfixmath/fix16.c **** {
 281:../libfixmath/fix16.c ****   uint8_t result = 0;
 282:../libfixmath/fix16.c ****   if (x == 0) return 32;
 283:../libfixmath/fix16.c ****   while (!(x & 0xF0000000)) { result += 4; x <<= 4; }
 284:../libfixmath/fix16.c ****   while (!(x & 0x80000000)) { result += 1; x <<= 1; }
 285:../libfixmath/fix16.c ****   return result;
 286:../libfixmath/fix16.c **** }
 287:../libfixmath/fix16.c **** #endif
 288:../libfixmath/fix16.c **** 
 289:../libfixmath/fix16.c **** fix16_t fix16_div(fix16_t a, fix16_t b)
 290:../libfixmath/fix16.c **** {
 723              		.loc 2 290 0
 724              		.cfi_startproc
 725              		@ args = 0, pretend = 0, frame = 40
 726              		@ frame_needed = 1, uses_anonymous_args = 0
 727              		@ link register save eliminated.
 728 0374 2DE9B003 		push	{r4, r5, r7, r8, r9}
 729              	.LCFI30:
 730              		.cfi_def_cfa_offset 20
 731              		.cfi_offset 9, -4
 732              		.cfi_offset 8, -8
 733              		.cfi_offset 7, -12
 734              		.cfi_offset 5, -16
 735              		.cfi_offset 4, -20
 736 0378 8BB0     		sub	sp, sp, #44
 737              	.LCFI31:
 738              		.cfi_def_cfa_offset 64
 739 037a 00AF     		add	r7, sp, #0
 740              	.LCFI32:
 741              		.cfi_def_cfa_register 7
 742 037c 7860     		str	r0, [r7, #4]
 743 037e 3960     		str	r1, [r7, #0]
 291:../libfixmath/fix16.c ****   // This uses a hardware 32/32 bit division multiple times, until we have
 292:../libfixmath/fix16.c ****   // computed all the bits in (a<<17)/b. Usually this takes 1-3 iterations.
 293:../libfixmath/fix16.c ****   
 294:../libfixmath/fix16.c ****   if (b == 0)
 744              		.loc 2 294 0
 745 0380 3B68     		ldr	r3, [r7, #0]
 746 0382 002B     		cmp	r3, #0
 747 0384 05D1     		bne	.L33
 295:../libfixmath/fix16.c ****       return fix16_min;
 748              		.loc 2 295 0
 749 0386 40F20003 		movw	r3, #:lower16:fix16_min
 750 038a C0F20003 		movt	r3, #:upper16:fix16_min
 751 038e 1B68     		ldr	r3, [r3, #0]
 752 0390 B9E0     		b	.L34
 753              	.L33:
 296:../libfixmath/fix16.c ****   
 297:../libfixmath/fix16.c ****   uint32_t remainder = (a >= 0) ? a : (-a);
 754              		.loc 2 297 0
 755 0392 7B68     		ldr	r3, [r7, #4]
 756 0394 002B     		cmp	r3, #0
 757 0396 B8BF     		it	lt
 758 0398 5B42     		rsblt	r3, r3, #0
 759 039a 7B62     		str	r3, [r7, #36]
 298:../libfixmath/fix16.c ****   uint32_t divider = (b >= 0) ? b : (-b);
 760              		.loc 2 298 0
 761 039c 3B68     		ldr	r3, [r7, #0]
 762 039e 002B     		cmp	r3, #0
 763 03a0 B8BF     		it	lt
 764 03a2 5B42     		rsblt	r3, r3, #0
 765 03a4 3B62     		str	r3, [r7, #32]
 299:../libfixmath/fix16.c ****   uint32_t quotient = 0;
 766              		.loc 2 299 0
 767 03a6 4FF00003 		mov	r3, #0
 768 03aa FB61     		str	r3, [r7, #28]
 300:../libfixmath/fix16.c ****   int bit_pos = 17;
 769              		.loc 2 300 0
 770 03ac 4FF01103 		mov	r3, #17
 771 03b0 BB61     		str	r3, [r7, #24]
 301:../libfixmath/fix16.c ****   
 302:../libfixmath/fix16.c ****   // Kick-start the division a bit.
 303:../libfixmath/fix16.c ****   // This improves speed in the worst-case scenarios where N and D are large
 304:../libfixmath/fix16.c ****   // It gets a lower estimate for the result by N/(D >> 17 + 1).
 305:../libfixmath/fix16.c ****   if (divider & 0xFFF00000)
 772              		.loc 2 305 0
 773 03b2 3B6A     		ldr	r3, [r7, #32]
 774 03b4 4FEA1353 		lsr	r3, r3, #20
 775 03b8 4FEA0353 		lsl	r3, r3, #20
 776 03bc 002B     		cmp	r3, #0
 777 03be 31D0     		beq	.L46
 778              	.LBB2:
 306:../libfixmath/fix16.c ****   {
 307:../libfixmath/fix16.c ****     uint32_t shifted_div = ((divider >> 17) + 1);
 779              		.loc 2 307 0
 780 03c0 3B6A     		ldr	r3, [r7, #32]
 781 03c2 4FEA5343 		lsr	r3, r3, #17
 782 03c6 03F10103 		add	r3, r3, #1
 783 03ca FB60     		str	r3, [r7, #12]
 308:../libfixmath/fix16.c ****     quotient = remainder / shifted_div;
 784              		.loc 2 308 0
 785 03cc 7A6A     		ldr	r2, [r7, #36]
 786 03ce FB68     		ldr	r3, [r7, #12]
 787 03d0 B2FBF3F3 		udiv	r3, r2, r3
 788 03d4 FB61     		str	r3, [r7, #28]
 309:../libfixmath/fix16.c ****     remainder -= ((uint64_t)quotient * divider) >> 17;
 789              		.loc 2 309 0
 790 03d6 FB69     		ldr	r3, [r7, #28]
 791 03d8 1C46     		mov	r4, r3
 792 03da 4FF00005 		mov	r5, #0
 793 03de 396A     		ldr	r1, [r7, #32]
 794 03e0 0A46     		mov	r2, r1
 795 03e2 4FF00003 		mov	r3, #0
 796 03e6 02FB05F0 		mul	r0, r2, r5
 797 03ea 04FB03F1 		mul	r1, r4, r3
 798 03ee 4118     		adds	r1, r0, r1
 799 03f0 A4FB0223 		umull	r2, r3, r4, r2
 800 03f4 C918     		adds	r1, r1, r3
 801 03f6 0B46     		mov	r3, r1
 802 03f8 4FEAC331 		lsl	r1, r3, #15
 803 03fc 4FEA5248 		lsr	r8, r2, #17
 804 0400 41EA0808 		orr	r8, r1, r8
 805 0404 4FEA5349 		lsr	r9, r3, #17
 806 0408 4346     		mov	r3, r8
 807 040a 7A6A     		ldr	r2, [r7, #36]
 808 040c D31A     		subs	r3, r2, r3
 809 040e 7B62     		str	r3, [r7, #36]
 810              	.LBE2:
 310:../libfixmath/fix16.c ****   }
 311:../libfixmath/fix16.c ****   
 312:../libfixmath/fix16.c ****   // If the divider is divisible by 2^n, take advantage of it.
 313:../libfixmath/fix16.c ****   while (!(divider & 0xF) && bit_pos >= 4)
 811              		.loc 2 313 0
 812 0410 08E0     		b	.L46
 813              	.L38:
 314:../libfixmath/fix16.c ****   {
 315:../libfixmath/fix16.c ****     divider >>= 4;
 814              		.loc 2 315 0
 815 0412 3B6A     		ldr	r3, [r7, #32]
 816 0414 4FEA1313 		lsr	r3, r3, #4
 817 0418 3B62     		str	r3, [r7, #32]
 316:../libfixmath/fix16.c ****     bit_pos -= 4;
 818              		.loc 2 316 0
 819 041a BB69     		ldr	r3, [r7, #24]
 820 041c A3F10403 		sub	r3, r3, #4
 821 0420 BB61     		str	r3, [r7, #24]
 822 0422 00E0     		b	.L36
 823              	.L46:
 313:../libfixmath/fix16.c ****   while (!(divider & 0xF) && bit_pos >= 4)
 824              		.loc 2 313 0
 825 0424 00BF     		nop
 826              	.L36:
 313:../libfixmath/fix16.c ****   while (!(divider & 0xF) && bit_pos >= 4)
 827              		.loc 2 313 0 is_stmt 0 discriminator 1
 828 0426 3B6A     		ldr	r3, [r7, #32]
 829 0428 03F00F03 		and	r3, r3, #15
 830 042c 002B     		cmp	r3, #0
 831 042e 44D1     		bne	.L39
 313:../libfixmath/fix16.c ****   while (!(divider & 0xF) && bit_pos >= 4)
 832              		.loc 2 313 0 discriminator 2
 833 0430 BB69     		ldr	r3, [r7, #24]
 834 0432 032B     		cmp	r3, #3
 835 0434 EDDC     		bgt	.L38
 317:../libfixmath/fix16.c ****   }
 318:../libfixmath/fix16.c ****   
 319:../libfixmath/fix16.c ****   while (remainder && bit_pos >= 0)
 836              		.loc 2 319 0 is_stmt 1
 837 0436 40E0     		b	.L39
 838              	.L43:
 839              	.LBB3:
 320:../libfixmath/fix16.c ****   {
 321:../libfixmath/fix16.c ****     // Shift remainder as much as we can without overflowing
 322:../libfixmath/fix16.c ****     int shift = clz(remainder);
 840              		.loc 2 322 0
 841 0438 7B6A     		ldr	r3, [r7, #36]
 842 043a B3FA83F3 		clz	r3, r3
 843 043e 7B61     		str	r3, [r7, #20]
 323:../libfixmath/fix16.c ****     if (shift > bit_pos) shift = bit_pos;
 844              		.loc 2 323 0
 845 0440 7A69     		ldr	r2, [r7, #20]
 846 0442 BB69     		ldr	r3, [r7, #24]
 847 0444 9A42     		cmp	r2, r3
 848 0446 01DD     		ble	.L40
 849              		.loc 2 323 0 is_stmt 0 discriminator 1
 850 0448 BB69     		ldr	r3, [r7, #24]
 851 044a 7B61     		str	r3, [r7, #20]
 852              	.L40:
 324:../libfixmath/fix16.c ****     remainder <<= shift;
 853              		.loc 2 324 0 is_stmt 1
 854 044c 7A6A     		ldr	r2, [r7, #36]
 855 044e 7B69     		ldr	r3, [r7, #20]
 856 0450 02FA03F3 		lsl	r3, r2, r3
 857 0454 7B62     		str	r3, [r7, #36]
 325:../libfixmath/fix16.c ****     bit_pos -= shift;
 858              		.loc 2 325 0
 859 0456 BA69     		ldr	r2, [r7, #24]
 860 0458 7B69     		ldr	r3, [r7, #20]
 861 045a D31A     		subs	r3, r2, r3
 862 045c BB61     		str	r3, [r7, #24]
 326:../libfixmath/fix16.c ****     
 327:../libfixmath/fix16.c ****     uint32_t div = remainder / divider;
 863              		.loc 2 327 0
 864 045e 7A6A     		ldr	r2, [r7, #36]
 865 0460 3B6A     		ldr	r3, [r7, #32]
 866 0462 B2FBF3F3 		udiv	r3, r2, r3
 867 0466 BB60     		str	r3, [r7, #8]
 328:../libfixmath/fix16.c ****     remainder = remainder % divider;
 868              		.loc 2 328 0
 869 0468 7B6A     		ldr	r3, [r7, #36]
 870 046a 3A6A     		ldr	r2, [r7, #32]
 871 046c B3FBF2F2 		udiv	r2, r3, r2
 872 0470 396A     		ldr	r1, [r7, #32]
 873 0472 01FB02F2 		mul	r2, r1, r2
 874 0476 9B1A     		subs	r3, r3, r2
 875 0478 7B62     		str	r3, [r7, #36]
 329:../libfixmath/fix16.c ****     quotient += div << bit_pos;
 876              		.loc 2 329 0
 877 047a BA68     		ldr	r2, [r7, #8]
 878 047c BB69     		ldr	r3, [r7, #24]
 879 047e 02FA03F3 		lsl	r3, r2, r3
 880 0482 FA69     		ldr	r2, [r7, #28]
 881 0484 D318     		adds	r3, r2, r3
 882 0486 FB61     		str	r3, [r7, #28]
 330:../libfixmath/fix16.c **** 
 331:../libfixmath/fix16.c ****     #ifndef FIXMATH_NO_OVERFLOW
 332:../libfixmath/fix16.c ****     if (div & ~(0xFFFFFFFF >> bit_pos))
 883              		.loc 2 332 0
 884 0488 4FF0FF32 		mov	r2, #-1
 885 048c BB69     		ldr	r3, [r7, #24]
 886 048e 22FA03F3 		lsr	r3, r2, r3
 887 0492 6FEA0302 		mvn	r2, r3
 888 0496 BB68     		ldr	r3, [r7, #8]
 889 0498 1340     		ands	r3, r3, r2
 890 049a 002B     		cmp	r3, #0
 891 049c 05D0     		beq	.L41
 333:../libfixmath/fix16.c ****         return fix16_overflow;
 892              		.loc 2 333 0
 893 049e 40F20003 		movw	r3, #:lower16:fix16_overflow
 894 04a2 C0F20003 		movt	r3, #:upper16:fix16_overflow
 895 04a6 1B68     		ldr	r3, [r3, #0]
 896 04a8 2DE0     		b	.L34
 897              	.L41:
 334:../libfixmath/fix16.c ****     #endif
 335:../libfixmath/fix16.c ****     
 336:../libfixmath/fix16.c ****     remainder <<= 1;
 898              		.loc 2 336 0
 899 04aa 7B6A     		ldr	r3, [r7, #36]
 900 04ac 4FEA4303 		lsl	r3, r3, #1
 901 04b0 7B62     		str	r3, [r7, #36]
 337:../libfixmath/fix16.c ****     bit_pos--;
 902              		.loc 2 337 0
 903 04b2 BB69     		ldr	r3, [r7, #24]
 904 04b4 03F1FF33 		add	r3, r3, #-1
 905 04b8 BB61     		str	r3, [r7, #24]
 906              	.L39:
 907              	.LBE3:
 319:../libfixmath/fix16.c ****   while (remainder && bit_pos >= 0)
 908              		.loc 2 319 0 discriminator 1
 909 04ba 7B6A     		ldr	r3, [r7, #36]
 910 04bc 002B     		cmp	r3, #0
 911 04be 02D0     		beq	.L42
 319:../libfixmath/fix16.c ****   while (remainder && bit_pos >= 0)
 912              		.loc 2 319 0 is_stmt 0 discriminator 2
 913 04c0 BB69     		ldr	r3, [r7, #24]
 914 04c2 002B     		cmp	r3, #0
 915 04c4 B8DA     		bge	.L43
 916              	.L42:
 338:../libfixmath/fix16.c ****   }
 339:../libfixmath/fix16.c ****   
 340:../libfixmath/fix16.c ****   #ifndef FIXMATH_NO_ROUNDING
 341:../libfixmath/fix16.c ****   // Quotient is always positive so rounding is easy
 342:../libfixmath/fix16.c ****   quotient++;
 917              		.loc 2 342 0 is_stmt 1
 918 04c6 FB69     		ldr	r3, [r7, #28]
 919 04c8 03F10103 		add	r3, r3, #1
 920 04cc FB61     		str	r3, [r7, #28]
 343:../libfixmath/fix16.c ****   #endif
 344:../libfixmath/fix16.c ****   
 345:../libfixmath/fix16.c ****   fix16_t result = quotient >> 1;
 921              		.loc 2 345 0
 922 04ce FB69     		ldr	r3, [r7, #28]
 923 04d0 4FEA5303 		lsr	r3, r3, #1
 924 04d4 3B61     		str	r3, [r7, #16]
 346:../libfixmath/fix16.c ****   
 347:../libfixmath/fix16.c ****   // Figure out the sign of the result
 348:../libfixmath/fix16.c ****   if ((a ^ b) & 0x80000000)
 925              		.loc 2 348 0
 926 04d6 7A68     		ldr	r2, [r7, #4]
 927 04d8 3B68     		ldr	r3, [r7, #0]
 928 04da 5340     		eors	r3, r3, r2
 929 04dc 002B     		cmp	r3, #0
 930 04de 11DA     		bge	.L44
 349:../libfixmath/fix16.c ****   {
 350:../libfixmath/fix16.c ****     #ifndef FIXMATH_NO_OVERFLOW
 351:../libfixmath/fix16.c ****     if (result == fix16_min)
 931              		.loc 2 351 0
 932 04e0 40F20003 		movw	r3, #:lower16:fix16_min
 933 04e4 C0F20003 		movt	r3, #:upper16:fix16_min
 934 04e8 1B68     		ldr	r3, [r3, #0]
 935 04ea 3A69     		ldr	r2, [r7, #16]
 936 04ec 9A42     		cmp	r2, r3
 937 04ee 05D1     		bne	.L45
 352:../libfixmath/fix16.c ****         return fix16_overflow;
 938              		.loc 2 352 0
 939 04f0 40F20003 		movw	r3, #:lower16:fix16_overflow
 940 04f4 C0F20003 		movt	r3, #:upper16:fix16_overflow
 941 04f8 1B68     		ldr	r3, [r3, #0]
 942 04fa 04E0     		b	.L34
 943              	.L45:
 353:../libfixmath/fix16.c ****     #endif
 354:../libfixmath/fix16.c ****     
 355:../libfixmath/fix16.c ****     result = -result;
 944              		.loc 2 355 0
 945 04fc 3B69     		ldr	r3, [r7, #16]
 946 04fe C3F10003 		rsb	r3, r3, #0
 947 0502 3B61     		str	r3, [r7, #16]
 948              	.L44:
 356:../libfixmath/fix16.c ****   }
 357:../libfixmath/fix16.c ****   
 358:../libfixmath/fix16.c ****   return result;
 949              		.loc 2 358 0
 950 0504 3B69     		ldr	r3, [r7, #16]
 951              	.L34:
 359:../libfixmath/fix16.c **** }
 952              		.loc 2 359 0
 953 0506 1846     		mov	r0, r3
 954 0508 07F12C07 		add	r7, r7, #44
 955 050c BD46     		mov	sp, r7
 956 050e BDE8B003 		pop	{r4, r5, r7, r8, r9}
 957 0512 7047     		bx	lr
 958              		.cfi_endproc
 959              	.LFE29:
 961              		.align	2
 962              		.global	fix16_sdiv
 963              		.thumb
 964              		.thumb_func
 966              	fix16_sdiv:
 967              	.LFB30:
 360:../libfixmath/fix16.c **** #endif
 361:../libfixmath/fix16.c **** 
 362:../libfixmath/fix16.c **** /* Alternative 32-bit implementation of fix16_div. Fastest on e.g. Atmel AVR.
 363:../libfixmath/fix16.c ****  * This does the division manually, and is therefore good for processors that
 364:../libfixmath/fix16.c ****  * do not have hardware division.
 365:../libfixmath/fix16.c ****  */
 366:../libfixmath/fix16.c **** #if defined(FIXMATH_OPTIMIZE_8BIT)
 367:../libfixmath/fix16.c **** fix16_t fix16_div(fix16_t a, fix16_t b)
 368:../libfixmath/fix16.c **** {
 369:../libfixmath/fix16.c ****   // This uses the basic binary restoring division algorithm.
 370:../libfixmath/fix16.c ****   // It appears to be faster to do the whole division manually than
 371:../libfixmath/fix16.c ****   // trying to compose a 64-bit divide out of 32-bit divisions on
 372:../libfixmath/fix16.c ****   // platforms without hardware divide.
 373:../libfixmath/fix16.c ****   
 374:../libfixmath/fix16.c ****   if (b == 0)
 375:../libfixmath/fix16.c ****     return fix16_min;
 376:../libfixmath/fix16.c ****   
 377:../libfixmath/fix16.c ****   uint32_t remainder = (a >= 0) ? a : (-a);
 378:../libfixmath/fix16.c ****   uint32_t divider = (b >= 0) ? b : (-b);
 379:../libfixmath/fix16.c **** 
 380:../libfixmath/fix16.c ****   uint32_t quotient = 0;
 381:../libfixmath/fix16.c ****   uint32_t bit = 0x10000;
 382:../libfixmath/fix16.c ****   
 383:../libfixmath/fix16.c ****   /* The algorithm requires D >= R */
 384:../libfixmath/fix16.c ****   while (divider < remainder)
 385:../libfixmath/fix16.c ****   {
 386:../libfixmath/fix16.c ****     divider <<= 1;
 387:../libfixmath/fix16.c ****     bit <<= 1;
 388:../libfixmath/fix16.c ****   }
 389:../libfixmath/fix16.c ****   
 390:../libfixmath/fix16.c ****   #ifndef FIXMATH_NO_OVERFLOW
 391:../libfixmath/fix16.c ****   if (!bit)
 392:../libfixmath/fix16.c ****     return fix16_overflow;
 393:../libfixmath/fix16.c ****   #endif
 394:../libfixmath/fix16.c ****   
 395:../libfixmath/fix16.c ****   if (divider & 0x80000000)
 396:../libfixmath/fix16.c ****   {
 397:../libfixmath/fix16.c ****     // Perform one step manually to avoid overflows later.
 398:../libfixmath/fix16.c ****     // We know that divider's bottom bit is 0 here.
 399:../libfixmath/fix16.c ****     if (remainder >= divider)
 400:../libfixmath/fix16.c ****     {
 401:../libfixmath/fix16.c ****         quotient |= bit;
 402:../libfixmath/fix16.c ****         remainder -= divider;
 403:../libfixmath/fix16.c ****     }
 404:../libfixmath/fix16.c ****     divider >>= 1;
 405:../libfixmath/fix16.c ****     bit >>= 1;
 406:../libfixmath/fix16.c ****   }
 407:../libfixmath/fix16.c ****   
 408:../libfixmath/fix16.c ****   /* Main division loop */
 409:../libfixmath/fix16.c ****   while (bit && remainder)
 410:../libfixmath/fix16.c ****   {
 411:../libfixmath/fix16.c ****     if (remainder >= divider)
 412:../libfixmath/fix16.c ****     {
 413:../libfixmath/fix16.c ****         quotient |= bit;
 414:../libfixmath/fix16.c ****         remainder -= divider;
 415:../libfixmath/fix16.c ****     }
 416:../libfixmath/fix16.c ****     
 417:../libfixmath/fix16.c ****     remainder <<= 1;
 418:../libfixmath/fix16.c ****     bit >>= 1;
 419:../libfixmath/fix16.c ****   }   
 420:../libfixmath/fix16.c ****       
 421:../libfixmath/fix16.c ****   #ifndef FIXMATH_NO_ROUNDING
 422:../libfixmath/fix16.c ****   if (remainder >= divider)
 423:../libfixmath/fix16.c ****   {
 424:../libfixmath/fix16.c ****     quotient++;
 425:../libfixmath/fix16.c ****   }
 426:../libfixmath/fix16.c ****   #endif
 427:../libfixmath/fix16.c ****   
 428:../libfixmath/fix16.c ****   fix16_t result = quotient;
 429:../libfixmath/fix16.c ****   
 430:../libfixmath/fix16.c ****   /* Figure out the sign of result */
 431:../libfixmath/fix16.c ****   if ((a ^ b) & 0x80000000)
 432:../libfixmath/fix16.c ****   {
 433:../libfixmath/fix16.c ****     #ifndef FIXMATH_NO_OVERFLOW
 434:../libfixmath/fix16.c ****     if (result == fix16_min)
 435:../libfixmath/fix16.c ****         return fix16_overflow;
 436:../libfixmath/fix16.c ****     #endif
 437:../libfixmath/fix16.c ****     
 438:../libfixmath/fix16.c ****     result = -result;
 439:../libfixmath/fix16.c ****   }
 440:../libfixmath/fix16.c ****   
 441:../libfixmath/fix16.c ****   return result;
 442:../libfixmath/fix16.c **** }
 443:../libfixmath/fix16.c **** #endif
 444:../libfixmath/fix16.c **** 
 445:../libfixmath/fix16.c **** #ifndef FIXMATH_NO_OVERFLOW
 446:../libfixmath/fix16.c **** /* Wrapper around fix16_div to add saturating arithmetic. */
 447:../libfixmath/fix16.c **** fix16_t fix16_sdiv(fix16_t inArg0, fix16_t inArg1) {
 968              		.loc 2 447 0
 969              		.cfi_startproc
 970              		@ args = 0, pretend = 0, frame = 16
 971              		@ frame_needed = 1, uses_anonymous_args = 0
 972 0514 80B5     		push	{r7, lr}
 973              	.LCFI33:
 974              		.cfi_def_cfa_offset 8
 975              		.cfi_offset 14, -4
 976              		.cfi_offset 7, -8
 977 0516 84B0     		sub	sp, sp, #16
 978              	.LCFI34:
 979              		.cfi_def_cfa_offset 24
 980 0518 00AF     		add	r7, sp, #0
 981              	.LCFI35:
 982              		.cfi_def_cfa_register 7
 983 051a 7860     		str	r0, [r7, #4]
 984 051c 3960     		str	r1, [r7, #0]
 448:../libfixmath/fix16.c ****   fix16_t result = fix16_div(inArg0, inArg1);
 985              		.loc 2 448 0
 986 051e 7868     		ldr	r0, [r7, #4]
 987 0520 3968     		ldr	r1, [r7, #0]
 988 0522 FFF7FEFF 		bl	fix16_div
 989 0526 F860     		str	r0, [r7, #12]
 449:../libfixmath/fix16.c ****   
 450:../libfixmath/fix16.c ****   if (result == fix16_overflow)
 990              		.loc 2 450 0
 991 0528 40F20003 		movw	r3, #:lower16:fix16_overflow
 992 052c C0F20003 		movt	r3, #:upper16:fix16_overflow
 993 0530 1B68     		ldr	r3, [r3, #0]
 994 0532 FA68     		ldr	r2, [r7, #12]
 995 0534 9A42     		cmp	r2, r3
 996 0536 19D1     		bne	.L48
 451:../libfixmath/fix16.c ****   {
 452:../libfixmath/fix16.c ****     if ((inArg0 >= 0) == (inArg1 >= 0))
 997              		.loc 2 452 0
 998 0538 7B68     		ldr	r3, [r7, #4]
 999 053a 4FEAD373 		lsr	r3, r3, #31
 1000 053e DAB2     		uxtb	r2, r3
 1001 0540 3B68     		ldr	r3, [r7, #0]
 1002 0542 6FEA0303 		mvn	r3, r3
 1003 0546 4FEAD373 		lsr	r3, r3, #31
 1004 054a DBB2     		uxtb	r3, r3
 1005 054c 5340     		eors	r3, r3, r2
 1006 054e DBB2     		uxtb	r3, r3
 1007 0550 002B     		cmp	r3, #0
 1008 0552 05D0     		beq	.L49
 453:../libfixmath/fix16.c ****       return fix16_max;
 1009              		.loc 2 453 0
 1010 0554 40F20003 		movw	r3, #:lower16:fix16_max
 1011 0558 C0F20003 		movt	r3, #:upper16:fix16_max
 1012 055c 1B68     		ldr	r3, [r3, #0]
 1013 055e 06E0     		b	.L50
 1014              	.L49:
 454:../libfixmath/fix16.c ****     else
 455:../libfixmath/fix16.c ****       return fix16_min;
 1015              		.loc 2 455 0
 1016 0560 40F20003 		movw	r3, #:lower16:fix16_min
 1017 0564 C0F20003 		movt	r3, #:upper16:fix16_min
 1018 0568 1B68     		ldr	r3, [r3, #0]
 1019 056a 00E0     		b	.L50
 1020              	.L48:
 456:../libfixmath/fix16.c ****   }
 457:../libfixmath/fix16.c ****   
 458:../libfixmath/fix16.c ****   return result;
 1021              		.loc 2 458 0
 1022 056c FB68     		ldr	r3, [r7, #12]
 1023              	.L50:
 459:../libfixmath/fix16.c **** }
 1024              		.loc 2 459 0
 1025 056e 1846     		mov	r0, r3
 1026 0570 07F11007 		add	r7, r7, #16
 1027 0574 BD46     		mov	sp, r7
 1028 0576 80BD     		pop	{r7, pc}
 1029              		.cfi_endproc
 1030              	.LFE30:
 1032              		.align	2
 1033              		.global	fix16_lerp8
 1034              		.thumb
 1035              		.thumb_func
 1037              	fix16_lerp8:
 1038              	.LFB31:
 460:../libfixmath/fix16.c **** #endif
 461:../libfixmath/fix16.c **** 
 462:../libfixmath/fix16.c **** fix16_t fix16_lerp8(fix16_t inArg0, fix16_t inArg1, uint8_t inFract) {
 1039              		.loc 2 462 0
 1040              		.cfi_startproc
 1041              		@ args = 0, pretend = 0, frame = 24
 1042              		@ frame_needed = 1, uses_anonymous_args = 0
 1043 0578 80B5     		push	{r7, lr}
 1044              	.LCFI36:
 1045              		.cfi_def_cfa_offset 8
 1046              		.cfi_offset 14, -4
 1047              		.cfi_offset 7, -8
 1048 057a 86B0     		sub	sp, sp, #24
 1049              	.LCFI37:
 1050              		.cfi_def_cfa_offset 32
 1051 057c 00AF     		add	r7, sp, #0
 1052              	.LCFI38:
 1053              		.cfi_def_cfa_register 7
 1054 057e F860     		str	r0, [r7, #12]
 1055 0580 B960     		str	r1, [r7, #8]
 1056 0582 1346     		mov	r3, r2
 1057 0584 FB71     		strb	r3, [r7, #7]
 463:../libfixmath/fix16.c **** 	int64_t tempOut = int64_mul_i32_i32(inArg0, ((1 << 8) - inFract));
 1058              		.loc 2 463 0
 1059 0586 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 1060 0588 C3F58073 		rsb	r3, r3, #256
 1061 058c F868     		ldr	r0, [r7, #12]
 1062 058e 1946     		mov	r1, r3
 1063 0590 FFF79CFD 		bl	int64_mul_i32_i32
 1064 0594 C7E90401 		strd	r0, [r7, #16]
 464:../libfixmath/fix16.c **** 	tempOut = int64_add(tempOut, int64_mul_i32_i32(inArg1, inFract));
 1065              		.loc 2 464 0
 1066 0598 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 1067 059a B868     		ldr	r0, [r7, #8]
 1068 059c 1946     		mov	r1, r3
 1069 059e FFF795FD 		bl	int64_mul_i32_i32
 1070 05a2 0246     		mov	r2, r0
 1071 05a4 0B46     		mov	r3, r1
 1072 05a6 D7E90401 		ldrd	r0, [r7, #16]
 1073 05aa FFF735FD 		bl	int64_add
 1074 05ae C7E90401 		strd	r0, [r7, #16]
 465:../libfixmath/fix16.c **** 	tempOut = int64_shift(tempOut, -8);
 1075              		.loc 2 465 0
 1076 05b2 D7E90401 		ldrd	r0, [r7, #16]
 1077 05b6 6FF00702 		mvn	r2, #7
 1078 05ba FFF743FD 		bl	int64_shift
 1079 05be C7E90401 		strd	r0, [r7, #16]
 466:../libfixmath/fix16.c **** 	return (fix16_t)int64_lo(tempOut);
 1080              		.loc 2 466 0
 1081 05c2 D7E90401 		ldrd	r0, [r7, #16]
 1082 05c6 FFF71BFD 		bl	int64_lo
 1083 05ca 0346     		mov	r3, r0
 467:../libfixmath/fix16.c **** }
 1084              		.loc 2 467 0
 1085 05cc 1846     		mov	r0, r3
 1086 05ce 07F11807 		add	r7, r7, #24
 1087 05d2 BD46     		mov	sp, r7
 1088 05d4 80BD     		pop	{r7, pc}
 1089              		.cfi_endproc
 1090              	.LFE31:
 1092 05d6 00BF     		.align	2
 1093              		.global	fix16_lerp16
 1094              		.thumb
 1095              		.thumb_func
 1097              	fix16_lerp16:
 1098              	.LFB32:
 468:../libfixmath/fix16.c **** 
 469:../libfixmath/fix16.c **** fix16_t fix16_lerp16(fix16_t inArg0, fix16_t inArg1, uint16_t inFract) {
 1099              		.loc 2 469 0
 1100              		.cfi_startproc
 1101              		@ args = 0, pretend = 0, frame = 24
 1102              		@ frame_needed = 1, uses_anonymous_args = 0
 1103 05d8 80B5     		push	{r7, lr}
 1104              	.LCFI39:
 1105              		.cfi_def_cfa_offset 8
 1106              		.cfi_offset 14, -4
 1107              		.cfi_offset 7, -8
 1108 05da 86B0     		sub	sp, sp, #24
 1109              	.LCFI40:
 1110              		.cfi_def_cfa_offset 32
 1111 05dc 00AF     		add	r7, sp, #0
 1112              	.LCFI41:
 1113              		.cfi_def_cfa_register 7
 1114 05de F860     		str	r0, [r7, #12]
 1115 05e0 B960     		str	r1, [r7, #8]
 1116 05e2 1346     		mov	r3, r2
 1117 05e4 FB80     		strh	r3, [r7, #6]	@ movhi
 470:../libfixmath/fix16.c **** 	int64_t tempOut = int64_mul_i32_i32(inArg0, ((1 << 16) - inFract));
 1118              		.loc 2 470 0
 1119 05e6 FB88     		ldrh	r3, [r7, #6]
 1120 05e8 C3F58033 		rsb	r3, r3, #65536
 1121 05ec F868     		ldr	r0, [r7, #12]
 1122 05ee 1946     		mov	r1, r3
 1123 05f0 FFF76CFD 		bl	int64_mul_i32_i32
 1124 05f4 C7E90401 		strd	r0, [r7, #16]
 471:../libfixmath/fix16.c **** 	tempOut = int64_add(tempOut, int64_mul_i32_i32(inArg1, inFract));
 1125              		.loc 2 471 0
 1126 05f8 FB88     		ldrh	r3, [r7, #6]
 1127 05fa B868     		ldr	r0, [r7, #8]
 1128 05fc 1946     		mov	r1, r3
 1129 05fe FFF765FD 		bl	int64_mul_i32_i32
 1130 0602 0246     		mov	r2, r0
 1131 0604 0B46     		mov	r3, r1
 1132 0606 D7E90401 		ldrd	r0, [r7, #16]
 1133 060a FFF705FD 		bl	int64_add
 1134 060e C7E90401 		strd	r0, [r7, #16]
 472:../libfixmath/fix16.c **** 	tempOut = int64_shift(tempOut, -16);
 1135              		.loc 2 472 0
 1136 0612 D7E90401 		ldrd	r0, [r7, #16]
 1137 0616 6FF00F02 		mvn	r2, #15
 1138 061a FFF713FD 		bl	int64_shift
 1139 061e C7E90401 		strd	r0, [r7, #16]
 473:../libfixmath/fix16.c **** 	return (fix16_t)int64_lo(tempOut);
 1140              		.loc 2 473 0
 1141 0622 D7E90401 		ldrd	r0, [r7, #16]
 1142 0626 FFF7EBFC 		bl	int64_lo
 1143 062a 0346     		mov	r3, r0
 474:../libfixmath/fix16.c **** }
 1144              		.loc 2 474 0
 1145 062c 1846     		mov	r0, r3
 1146 062e 07F11807 		add	r7, r7, #24
 1147 0632 BD46     		mov	sp, r7
 1148 0634 80BD     		pop	{r7, pc}
 1149              		.cfi_endproc
 1150              	.LFE32:
 1152 0636 00BF     		.align	2
 1153              		.global	fix16_lerp32
 1154              		.thumb
 1155              		.thumb_func
 1157              	fix16_lerp32:
 1158              	.LFB33:
 475:../libfixmath/fix16.c **** 
 476:../libfixmath/fix16.c **** #ifndef FIXMATH_NO_64BIT
 477:../libfixmath/fix16.c **** fix16_t fix16_lerp32(fix16_t inArg0, fix16_t inArg1, uint32_t inFract) {
 1159              		.loc 2 477 0
 1160              		.cfi_startproc
 1161              		@ args = 0, pretend = 0, frame = 24
 1162              		@ frame_needed = 1, uses_anonymous_args = 0
 1163              		@ link register save eliminated.
 1164 0638 B0B4     		push	{r4, r5, r7}
 1165              	.LCFI42:
 1166              		.cfi_def_cfa_offset 12
 1167              		.cfi_offset 7, -4
 1168              		.cfi_offset 5, -8
 1169              		.cfi_offset 4, -12
 1170 063a 87B0     		sub	sp, sp, #28
 1171              	.LCFI43:
 1172              		.cfi_def_cfa_offset 40
 1173 063c 00AF     		add	r7, sp, #0
 1174              	.LCFI44:
 1175              		.cfi_def_cfa_register 7
 1176 063e F860     		str	r0, [r7, #12]
 1177 0640 B960     		str	r1, [r7, #8]
 1178 0642 7A60     		str	r2, [r7, #4]
 478:../libfixmath/fix16.c **** 	int64_t tempOut;
 479:../libfixmath/fix16.c **** 	tempOut   = ((int64_t)inArg0 * (0 - inFract));
 1179              		.loc 2 479 0
 1180 0644 F968     		ldr	r1, [r7, #12]
 1181 0646 0A46     		mov	r2, r1
 1182 0648 4FEAE273 		asr	r3, r2, #31
 1183 064c 7968     		ldr	r1, [r7, #4]
 1184 064e C1F10004 		rsb	r4, r1, #0
 1185 0652 2046     		mov	r0, r4
 1186 0654 4FF00001 		mov	r1, #0
 1187 0658 00FB03F5 		mul	r5, r0, r3
 1188 065c 02FB01F4 		mul	r4, r2, r1
 1189 0660 2C19     		adds	r4, r5, r4
 1190 0662 A2FB0023 		umull	r2, r3, r2, r0
 1191 0666 E118     		adds	r1, r4, r3
 1192 0668 0B46     		mov	r3, r1
 1193 066a C7E90423 		strd	r2, [r7, #16]
 1194 066e C7E90423 		strd	r2, [r7, #16]
 480:../libfixmath/fix16.c **** 	tempOut  += ((int64_t)inArg1 * inFract);
 1195              		.loc 2 480 0
 1196 0672 B968     		ldr	r1, [r7, #8]
 1197 0674 0A46     		mov	r2, r1
 1198 0676 4FEAE273 		asr	r3, r2, #31
 1199 067a 7C68     		ldr	r4, [r7, #4]
 1200 067c 2046     		mov	r0, r4
 1201 067e 4FF00001 		mov	r1, #0
 1202 0682 00FB03F5 		mul	r5, r0, r3
 1203 0686 02FB01F4 		mul	r4, r2, r1
 1204 068a 2C19     		adds	r4, r5, r4
 1205 068c A2FB0023 		umull	r2, r3, r2, r0
 1206 0690 E118     		adds	r1, r4, r3
 1207 0692 0B46     		mov	r3, r1
 1208 0694 D7E90401 		ldrd	r0, [r7, #16]
 1209 0698 1218     		adds	r2, r2, r0
 1210 069a 43EB0103 		adc	r3, r3, r1
 1211 069e C7E90423 		strd	r2, [r7, #16]
 481:../libfixmath/fix16.c **** 	tempOut >>= 32;
 1212              		.loc 2 481 0
 1213 06a2 7B69     		ldr	r3, [r7, #20]
 1214 06a4 1B46     		mov	r3, r3
 1215 06a6 3B61     		str	r3, [r7, #16]
 1216 06a8 7B69     		ldr	r3, [r7, #20]
 1217 06aa 4FEAE373 		asr	r3, r3, #31
 1218 06ae 7B61     		str	r3, [r7, #20]
 482:../libfixmath/fix16.c **** 	return (fix16_t)tempOut;
 1219              		.loc 2 482 0
 1220 06b0 3B69     		ldr	r3, [r7, #16]
 483:../libfixmath/fix16.c **** }
 1221              		.loc 2 483 0
 1222 06b2 1846     		mov	r0, r3
 1223 06b4 07F11C07 		add	r7, r7, #28
 1224 06b8 BD46     		mov	sp, r7
 1225 06ba B0BC     		pop	{r4, r5, r7}
 1226 06bc 7047     		bx	lr
 1227              		.cfi_endproc
 1228              	.LFE33:
 1230              	.Letext0:
 1231              		.file 3 "/opt/CodeSourcery/arm-2011.09/bin/../lib/gcc/arm-none-eabi/4.6.1/../../../../arm-none-eab
 1232              		.file 4 "../libfixmath/fix16.h"
DEFINED SYMBOLS
                            *ABS*:00000000 fix16.c
     /tmp/ccCsDJbi.s:19     .rodata:00000000 $d
     /tmp/ccCsDJbi.s:22     .rodata:00000000 FOUR_DIV_PI
     /tmp/ccCsDJbi.s:27     .rodata:00000004 _FOUR_DIV_PI2
     /tmp/ccCsDJbi.s:32     .rodata:00000008 X4_CORRECTION_COMPONENT
     /tmp/ccCsDJbi.s:37     .rodata:0000000c PI_DIV_4
     /tmp/ccCsDJbi.s:42     .rodata:00000010 THREE_PI_DIV_4
     /tmp/ccCsDJbi.s:47     .rodata:00000014 fix16_max
     /tmp/ccCsDJbi.s:52     .rodata:00000018 fix16_min
     /tmp/ccCsDJbi.s:57     .rodata:0000001c fix16_overflow
     /tmp/ccCsDJbi.s:62     .rodata:00000020 fix16_pi
     /tmp/ccCsDJbi.s:67     .rodata:00000024 fix16_e
     /tmp/ccCsDJbi.s:72     .rodata:00000028 fix16_one
     /tmp/ccCsDJbi.s:75     .text:00000000 $t
     /tmp/ccCsDJbi.s:79     .text:00000000 int64_lo
     /tmp/ccCsDJbi.s:112    .text:00000018 int64_add
     /tmp/ccCsDJbi.s:149    .text:00000044 int64_shift
     /tmp/ccCsDJbi.s:228    .text:000000cc int64_mul_i32_i32
     /tmp/ccCsDJbi.s:267    .text:000000f4 fix16_add
     /tmp/ccCsDJbi.s:332    .text:0000013c fix16_sub
     /tmp/ccCsDJbi.s:396    .text:00000184 fix16_sadd
     /tmp/ccCsDJbi.s:461    .text:000001d4 fix16_ssub
     /tmp/ccCsDJbi.s:526    .text:00000224 fix16_mul
     /tmp/ccCsDJbi.s:650    .text:00000310 fix16_smul
     /tmp/ccCsDJbi.s:721    .text:00000374 fix16_div
     /tmp/ccCsDJbi.s:966    .text:00000514 fix16_sdiv
     /tmp/ccCsDJbi.s:1037   .text:00000578 fix16_lerp8
     /tmp/ccCsDJbi.s:1097   .text:000005d8 fix16_lerp16
     /tmp/ccCsDJbi.s:1157   .text:00000638 fix16_lerp32
                     .debug_frame:00000010 $d

NO UNDEFINED SYMBOLS
