   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"fix16_sqrt.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.section	.rodata
  19              		.align	2
  22              	FOUR_DIV_PI:
  23 0000 F3450100 		.word	83443
  24              		.align	2
  27              	_FOUR_DIV_PI2:
  28 0004 4098FFFF 		.word	-26560
  29              		.align	2
  32              	X4_CORRECTION_COMPONENT:
  33 0008 9A390000 		.word	14746
  34              		.align	2
  37              	PI_DIV_4:
  38 000c 0FC90000 		.word	51471
  39              		.align	2
  42              	THREE_PI_DIV_4:
  43 0010 2F5B0200 		.word	154415
  44              		.align	2
  47              	fix16_max:
  48 0014 FFFFFF7F 		.word	2147483647
  49              		.align	2
  52              	fix16_min:
  53 0018 00000080 		.word	-2147483648
  54              		.align	2
  57              	fix16_overflow:
  58 001c 00000080 		.word	-2147483648
  59              		.align	2
  62              	fix16_pi:
  63 0020 3F240300 		.word	205887
  64              		.align	2
  67              	fix16_e:
  68 0024 E1B70200 		.word	178145
  69              		.align	2
  72              	fix16_one:
  73 0028 00000100 		.word	65536
  74              		.text
  75              		.align	2
  76              		.global	fix16_sqrt
  77              		.thumb
  78              		.thumb_func
  80              	fix16_sqrt:
  81              	.LFB6:
  82              		.file 1 "../libfixmath/fix16_sqrt.c"
   1:../libfixmath/fix16_sqrt.c **** #include "fix16.h"
   2:../libfixmath/fix16_sqrt.c **** 
   3:../libfixmath/fix16_sqrt.c **** /* The square root algorithm is quite directly from
   4:../libfixmath/fix16_sqrt.c ****  * http://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Binary_numeral_system_.28base_2.2
   5:../libfixmath/fix16_sqrt.c ****  * An important difference is that it is split to two parts
   6:../libfixmath/fix16_sqrt.c ****  * in order to use only 32-bit operations.
   7:../libfixmath/fix16_sqrt.c ****  *
   8:../libfixmath/fix16_sqrt.c ****  * Note that for negative numbers we return -sqrt(-inValue).
   9:../libfixmath/fix16_sqrt.c ****  * Not sure if someone relies on this behaviour, but not going
  10:../libfixmath/fix16_sqrt.c ****  * to break it for now. It doesn't slow the code much overall.
  11:../libfixmath/fix16_sqrt.c ****  */
  12:../libfixmath/fix16_sqrt.c **** fix16_t fix16_sqrt(fix16_t inValue) {
  83              		.loc 1 12 0
  84              		.cfi_startproc
  85              		@ args = 0, pretend = 0, frame = 24
  86              		@ frame_needed = 1, uses_anonymous_args = 0
  87              		@ link register save eliminated.
  88 0000 80B4     		push	{r7}
  89              	.LCFI0:
  90              		.cfi_def_cfa_offset 4
  91              		.cfi_offset 7, -4
  92 0002 87B0     		sub	sp, sp, #28
  93              	.LCFI1:
  94              		.cfi_def_cfa_offset 32
  95 0004 00AF     		add	r7, sp, #0
  96              	.LCFI2:
  97              		.cfi_def_cfa_register 7
  98 0006 7860     		str	r0, [r7, #4]
  13:../libfixmath/fix16_sqrt.c ****   uint8_t neg = (inValue < 0);
  99              		.loc 1 13 0
 100 0008 7B68     		ldr	r3, [r7, #4]
 101 000a 4FEAD373 		lsr	r3, r3, #31
 102 000e BB72     		strb	r3, [r7, #10]
  14:../libfixmath/fix16_sqrt.c ****   uint32_t num = (neg ? -inValue : inValue);
 103              		.loc 1 14 0
 104 0010 BB7A     		ldrb	r3, [r7, #10]	@ zero_extendqisi2
 105 0012 002B     		cmp	r3, #0
 106 0014 03D0     		beq	.L2
 107              		.loc 1 14 0 is_stmt 0 discriminator 1
 108 0016 7B68     		ldr	r3, [r7, #4]
 109 0018 C3F10003 		rsb	r3, r3, #0
 110 001c 00E0     		b	.L3
 111              	.L2:
 112              		.loc 1 14 0 discriminator 2
 113 001e 7B68     		ldr	r3, [r7, #4]
 114              	.L3:
 115              		.loc 1 14 0 discriminator 3
 116 0020 7B61     		str	r3, [r7, #20]
  15:../libfixmath/fix16_sqrt.c ****   uint32_t result = 0;
 117              		.loc 1 15 0 is_stmt 1 discriminator 3
 118 0022 4FF00003 		mov	r3, #0
 119 0026 3B61     		str	r3, [r7, #16]
  16:../libfixmath/fix16_sqrt.c ****   uint32_t bit;
  17:../libfixmath/fix16_sqrt.c ****   uint8_t n;
  18:../libfixmath/fix16_sqrt.c ****   
  19:../libfixmath/fix16_sqrt.c ****   // Many numbers will be less than 15, so
  20:../libfixmath/fix16_sqrt.c ****   // this gives a good balance between time spent
  21:../libfixmath/fix16_sqrt.c ****   // in if vs. time spent in the while loop
  22:../libfixmath/fix16_sqrt.c ****   // when searching for the starting value.
  23:../libfixmath/fix16_sqrt.c ****   if (num & 0xFFF00000)
 120              		.loc 1 23 0 discriminator 3
 121 0028 7B69     		ldr	r3, [r7, #20]
 122 002a 4FEA1353 		lsr	r3, r3, #20
 123 002e 4FEA0353 		lsl	r3, r3, #20
 124 0032 002B     		cmp	r3, #0
 125 0034 03D0     		beq	.L4
  24:../libfixmath/fix16_sqrt.c ****     bit = (uint32_t)1 << 30;
 126              		.loc 1 24 0
 127 0036 4FF08043 		mov	r3, #1073741824
 128 003a FB60     		str	r3, [r7, #12]
  25:../libfixmath/fix16_sqrt.c ****   else
  26:../libfixmath/fix16_sqrt.c ****     bit = (uint32_t)1 << 18;
  27:../libfixmath/fix16_sqrt.c ****   
  28:../libfixmath/fix16_sqrt.c ****   while (bit > num) bit >>= 2;
 129              		.loc 1 28 0
 130 003c 07E0     		b	.L6
 131              	.L4:
  26:../libfixmath/fix16_sqrt.c ****     bit = (uint32_t)1 << 18;
 132              		.loc 1 26 0
 133 003e 4FF48023 		mov	r3, #262144
 134 0042 FB60     		str	r3, [r7, #12]
 135              		.loc 1 28 0
 136 0044 03E0     		b	.L6
 137              	.L7:
 138              		.loc 1 28 0 is_stmt 0 discriminator 2
 139 0046 FB68     		ldr	r3, [r7, #12]
 140 0048 4FEA9303 		lsr	r3, r3, #2
 141 004c FB60     		str	r3, [r7, #12]
 142              	.L6:
 143              		.loc 1 28 0 discriminator 1
 144 004e FA68     		ldr	r2, [r7, #12]
 145 0050 7B69     		ldr	r3, [r7, #20]
 146 0052 9A42     		cmp	r2, r3
 147 0054 F7D8     		bhi	.L7
  29:../libfixmath/fix16_sqrt.c ****   
  30:../libfixmath/fix16_sqrt.c ****   // The main part is executed twice, in order to avoid
  31:../libfixmath/fix16_sqrt.c ****   // using 64 bit values in computations.
  32:../libfixmath/fix16_sqrt.c ****   for (n = 0; n < 2; n++)
 148              		.loc 1 32 0 is_stmt 1
 149 0056 4FF00003 		mov	r3, #0
 150 005a FB72     		strb	r3, [r7, #11]
 151 005c 45E0     		b	.L8
 152              	.L12:
  33:../libfixmath/fix16_sqrt.c ****   {
  34:../libfixmath/fix16_sqrt.c ****     // First we get the top 24 bits of the answer.
  35:../libfixmath/fix16_sqrt.c ****     while (bit)
  36:../libfixmath/fix16_sqrt.c ****     {
  37:../libfixmath/fix16_sqrt.c ****       if (num >= result + bit)
 153              		.loc 1 37 0
 154 005e 3A69     		ldr	r2, [r7, #16]
 155 0060 FB68     		ldr	r3, [r7, #12]
 156 0062 D218     		adds	r2, r2, r3
 157 0064 7B69     		ldr	r3, [r7, #20]
 158 0066 9A42     		cmp	r2, r3
 159 0068 0CD8     		bhi	.L10
  38:../libfixmath/fix16_sqrt.c ****       {
  39:../libfixmath/fix16_sqrt.c ****         num -= result + bit;
 160              		.loc 1 39 0
 161 006a 3A69     		ldr	r2, [r7, #16]
 162 006c FB68     		ldr	r3, [r7, #12]
 163 006e D318     		adds	r3, r2, r3
 164 0070 7A69     		ldr	r2, [r7, #20]
 165 0072 D31A     		subs	r3, r2, r3
 166 0074 7B61     		str	r3, [r7, #20]
  40:../libfixmath/fix16_sqrt.c ****         result = (result >> 1) + bit;
 167              		.loc 1 40 0
 168 0076 3B69     		ldr	r3, [r7, #16]
 169 0078 4FEA5302 		lsr	r2, r3, #1
 170 007c FB68     		ldr	r3, [r7, #12]
 171 007e D318     		adds	r3, r2, r3
 172 0080 3B61     		str	r3, [r7, #16]
 173 0082 03E0     		b	.L11
 174              	.L10:
  41:../libfixmath/fix16_sqrt.c ****       }
  42:../libfixmath/fix16_sqrt.c ****       else
  43:../libfixmath/fix16_sqrt.c ****       {
  44:../libfixmath/fix16_sqrt.c ****         result = (result >> 1);
 175              		.loc 1 44 0
 176 0084 3B69     		ldr	r3, [r7, #16]
 177 0086 4FEA5303 		lsr	r3, r3, #1
 178 008a 3B61     		str	r3, [r7, #16]
 179              	.L11:
  45:../libfixmath/fix16_sqrt.c ****       }
  46:../libfixmath/fix16_sqrt.c ****       bit >>= 2;
 180              		.loc 1 46 0
 181 008c FB68     		ldr	r3, [r7, #12]
 182 008e 4FEA9303 		lsr	r3, r3, #2
 183 0092 FB60     		str	r3, [r7, #12]
 184              	.L9:
  35:../libfixmath/fix16_sqrt.c ****     while (bit)
 185              		.loc 1 35 0 discriminator 1
 186 0094 FB68     		ldr	r3, [r7, #12]
 187 0096 002B     		cmp	r3, #0
 188 0098 E1D1     		bne	.L12
  47:../libfixmath/fix16_sqrt.c ****     }
  48:../libfixmath/fix16_sqrt.c ****     
  49:../libfixmath/fix16_sqrt.c ****     if (n == 0)
 189              		.loc 1 49 0
 190 009a FB7A     		ldrb	r3, [r7, #11]	@ zero_extendqisi2
 191 009c 002B     		cmp	r3, #0
 192 009e 20D1     		bne	.L13
  50:../libfixmath/fix16_sqrt.c ****     {
  51:../libfixmath/fix16_sqrt.c ****       // Then process it again to get the lowest 8 bits.
  52:../libfixmath/fix16_sqrt.c ****       if (num > 65535)
 193              		.loc 1 52 0
 194 00a0 7A69     		ldr	r2, [r7, #20]
 195 00a2 4FF6FF73 		movw	r3, #65535
 196 00a6 9A42     		cmp	r2, r3
 197 00a8 10D9     		bls	.L14
  53:../libfixmath/fix16_sqrt.c ****       {
  54:../libfixmath/fix16_sqrt.c ****         // The remainder 'num' is too large to be shifted left
  55:../libfixmath/fix16_sqrt.c ****         // by 16, so we have to add 1 to result manually and
  56:../libfixmath/fix16_sqrt.c ****         // adjust 'num' accordingly.
  57:../libfixmath/fix16_sqrt.c ****         // num = a - (result + 0.5)^2
  58:../libfixmath/fix16_sqrt.c ****         //   = num + result^2 - (result + 0.5)^2
  59:../libfixmath/fix16_sqrt.c ****         //   = num - result - 0.5
  60:../libfixmath/fix16_sqrt.c ****         num -= result;
 198              		.loc 1 60 0
 199 00aa 7A69     		ldr	r2, [r7, #20]
 200 00ac 3B69     		ldr	r3, [r7, #16]
 201 00ae D31A     		subs	r3, r2, r3
 202 00b0 7B61     		str	r3, [r7, #20]
  61:../libfixmath/fix16_sqrt.c ****         num = (num << 16) - 0x8000;
 203              		.loc 1 61 0
 204 00b2 7B69     		ldr	r3, [r7, #20]
 205 00b4 4FEA0343 		lsl	r3, r3, #16
 206 00b8 A3F50043 		sub	r3, r3, #32768
 207 00bc 7B61     		str	r3, [r7, #20]
  62:../libfixmath/fix16_sqrt.c ****         result = (result << 16) + 0x8000;
 208              		.loc 1 62 0
 209 00be 3B69     		ldr	r3, [r7, #16]
 210 00c0 4FEA0343 		lsl	r3, r3, #16
 211 00c4 03F50043 		add	r3, r3, #32768
 212 00c8 3B61     		str	r3, [r7, #16]
 213 00ca 07E0     		b	.L15
 214              	.L14:
  63:../libfixmath/fix16_sqrt.c ****       }
  64:../libfixmath/fix16_sqrt.c ****       else
  65:../libfixmath/fix16_sqrt.c ****       {
  66:../libfixmath/fix16_sqrt.c ****         num <<= 16;
 215              		.loc 1 66 0
 216 00cc 7B69     		ldr	r3, [r7, #20]
 217 00ce 4FEA0343 		lsl	r3, r3, #16
 218 00d2 7B61     		str	r3, [r7, #20]
  67:../libfixmath/fix16_sqrt.c ****         result <<= 16;
 219              		.loc 1 67 0
 220 00d4 3B69     		ldr	r3, [r7, #16]
 221 00d6 4FEA0343 		lsl	r3, r3, #16
 222 00da 3B61     		str	r3, [r7, #16]
 223              	.L15:
  68:../libfixmath/fix16_sqrt.c ****       }
  69:../libfixmath/fix16_sqrt.c ****       
  70:../libfixmath/fix16_sqrt.c ****       bit = 1 << 14;
 224              		.loc 1 70 0
 225 00dc 4FF48043 		mov	r3, #16384
 226 00e0 FB60     		str	r3, [r7, #12]
 227              	.L13:
  32:../libfixmath/fix16_sqrt.c ****   for (n = 0; n < 2; n++)
 228              		.loc 1 32 0
 229 00e2 FB7A     		ldrb	r3, [r7, #11]
 230 00e4 03F10103 		add	r3, r3, #1
 231 00e8 FB72     		strb	r3, [r7, #11]
 232              	.L8:
  32:../libfixmath/fix16_sqrt.c ****   for (n = 0; n < 2; n++)
 233              		.loc 1 32 0 is_stmt 0 discriminator 1
 234 00ea FB7A     		ldrb	r3, [r7, #11]	@ zero_extendqisi2
 235 00ec 012B     		cmp	r3, #1
 236 00ee D1D9     		bls	.L9
  71:../libfixmath/fix16_sqrt.c ****     }
  72:../libfixmath/fix16_sqrt.c ****   }
  73:../libfixmath/fix16_sqrt.c **** 
  74:../libfixmath/fix16_sqrt.c **** #ifndef FIXMATH_NO_ROUNDING
  75:../libfixmath/fix16_sqrt.c ****   // Finally, if next bit would have been 1, round the result upwards.
  76:../libfixmath/fix16_sqrt.c ****   if (num > result)
 237              		.loc 1 76 0 is_stmt 1
 238 00f0 7A69     		ldr	r2, [r7, #20]
 239 00f2 3B69     		ldr	r3, [r7, #16]
 240 00f4 9A42     		cmp	r2, r3
 241 00f6 03D9     		bls	.L17
  77:../libfixmath/fix16_sqrt.c ****   {
  78:../libfixmath/fix16_sqrt.c ****     result++;
 242              		.loc 1 78 0
 243 00f8 3B69     		ldr	r3, [r7, #16]
 244 00fa 03F10103 		add	r3, r3, #1
 245 00fe 3B61     		str	r3, [r7, #16]
 246              	.L17:
  79:../libfixmath/fix16_sqrt.c ****   }
  80:../libfixmath/fix16_sqrt.c **** #endif
  81:../libfixmath/fix16_sqrt.c ****   
  82:../libfixmath/fix16_sqrt.c ****   return (neg ? -result : result);
 247              		.loc 1 82 0
 248 0100 BB7A     		ldrb	r3, [r7, #10]	@ zero_extendqisi2
 249 0102 002B     		cmp	r3, #0
 250 0104 03D0     		beq	.L18
 251              		.loc 1 82 0 is_stmt 0 discriminator 1
 252 0106 3B69     		ldr	r3, [r7, #16]
 253 0108 C3F10003 		rsb	r3, r3, #0
 254 010c 00E0     		b	.L19
 255              	.L18:
 256              		.loc 1 82 0 discriminator 2
 257 010e 3B69     		ldr	r3, [r7, #16]
 258              	.L19:
  83:../libfixmath/fix16_sqrt.c **** }
 259              		.loc 1 83 0 is_stmt 1 discriminator 3
 260 0110 1846     		mov	r0, r3
 261 0112 07F11C07 		add	r7, r7, #28
 262 0116 BD46     		mov	sp, r7
 263 0118 80BC     		pop	{r7}
 264 011a 7047     		bx	lr
 265              		.cfi_endproc
 266              	.LFE6:
 268              	.Letext0:
 269              		.file 2 "/opt/CodeSourcery/arm-2011.09/bin/../lib/gcc/arm-none-eabi/4.6.1/../../../../arm-none-eab
 270              		.file 3 "../libfixmath/fix16.h"
DEFINED SYMBOLS
                            *ABS*:00000000 fix16_sqrt.c
     /tmp/cc9oL6xn.s:19     .rodata:00000000 $d
     /tmp/cc9oL6xn.s:22     .rodata:00000000 FOUR_DIV_PI
     /tmp/cc9oL6xn.s:27     .rodata:00000004 _FOUR_DIV_PI2
     /tmp/cc9oL6xn.s:32     .rodata:00000008 X4_CORRECTION_COMPONENT
     /tmp/cc9oL6xn.s:37     .rodata:0000000c PI_DIV_4
     /tmp/cc9oL6xn.s:42     .rodata:00000010 THREE_PI_DIV_4
     /tmp/cc9oL6xn.s:47     .rodata:00000014 fix16_max
     /tmp/cc9oL6xn.s:52     .rodata:00000018 fix16_min
     /tmp/cc9oL6xn.s:57     .rodata:0000001c fix16_overflow
     /tmp/cc9oL6xn.s:62     .rodata:00000020 fix16_pi
     /tmp/cc9oL6xn.s:67     .rodata:00000024 fix16_e
     /tmp/cc9oL6xn.s:72     .rodata:00000028 fix16_one
     /tmp/cc9oL6xn.s:75     .text:00000000 $t
     /tmp/cc9oL6xn.s:80     .text:00000000 fix16_sqrt
                     .debug_frame:00000010 $d

NO UNDEFINED SYMBOLS
